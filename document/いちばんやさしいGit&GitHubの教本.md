**<details><summary>はじめに</summary>**
ソースコードの履歴を管理するツールとして誕生したGitは、今や習得が欠かせないほど普及し、多くの開発者に親しまれています。Gitを使うと、複数人で安心して同じファイルを更新したり、変更の履歴をわかりやすく保ったりすることができます。また、Gitを活用したWebサービスであるGitHubの登場により、インターネット上での共同開発が活発になりました。

近年では、執筆作業やドキュメントの管理など、プログラミング以外にも多くの用途でGitとGitHubが利用されています。

本書は大きく分けて二部構成となっています。前半では、手元のパソコンでファイルを実際にバージョン管理しながら、Gitの基本的な使い方を解説しています。後半は、実践的なワークフローに沿ってGitHubを使い、チームメンバーと一緒に開発を進めるための知識を身につけられる内容としています。

全体を通し、コマンドラインを使った操作が中心であることは大きな特徴です。難しそうに思えるかもしれませんが、未経験者でも理解できるように配慮しているので、心配することはありません。概念や操作方法を丁寧に解説し、「なぜそうするのか」といった説明も多く入れました。また、改訂にあたり、新しいGitコマンドやGitHubの機能にも対応したのに加え、知っておくと実務で役に立つ新しい慣習も紹介しています。</details>


# Chapter1 Gitの基本を学ぼう
Gitの使い方の前に、まずこのChapterで「Gitの基本の考え方」から説明していきます。

これらを理解せずに操作だけ覚えても応用が利きません。Chapter 2以降でGitを操作するための準備として挑みましょう。

**<details><summary>Lesson 01 [バージョン管理]バージョン管理とその目的を理解しましょう</summary>**

まずは、Gitの役割を説明します。具体的な使い方や捜査を知る前に、「なぜGitを使うのか」について把握しておくことはとても重要です。
このLessonの内容をしっかりおさえ、最後まで目的を見失わずに学習を進めていきましょう。
- Gitを学ぶ上で欠かせない、バージョンという概念
    
    アップデートするにつれて変化するファイルの状態のことを「バージョン」といいます。議事録を例にとると、下書きした状態、清書した状態、加筆修正した状態などが考えられます。
    
    また、作業を重ねる中で、「編集前の内容をあとから参照したい」「間違った変更をしても元に戻せるようにしておきたい」といった理由から、ファイルをコピーしてバックアップを取った経験はないでしょうか。そのように、同じファイルの複数バージョンを保持することを「バージョン管理」と呼びます。
    
    - ファイルの状態のことをバージョンと呼ぶ
        - 同じファイルの複数バージョンを保持すること＝バージョン管理
- Gitはバージョン管理を行う
    
    Gitは、ファイルのバージョン管理を行うために、多くのプロジェクトで使われているツールです。次々と発生するファイルの変更をバージョンとして記録し、記録した地点へいつでも戻れる仕組みを提供することが大きな特徴です。なお、そうしたツールはGit以外にも存在しており、「バージョン管理システム」と総称されます。
    
    - バージョン管理システムにより、変更を記録した地点同士を行き来できる
        - 記録したバージョンはいつでも引き出せる
- なぜバージョン管理システムが必要なのか知ろう
    
    原始的なバージョン管理として、「ファイルをコピーしてバックアップを取り続ける」という方法があります。この方法では大抵、ファイル名を工夫することでバージョンを表します。特別なツールを必要としない手軽さから、よく使われる手法の1つです。しかし、毎回コピーするのに手間がかかりますし、ファイル名の一貫性が失われた途端に何が起こったかわかりづらくなってしまうのが欠点です。特に、複数人で同じファイルを使って作業をする場合、他の人による変更を把握するのは難しく、うっかり上書きや削除をしてしまう可能性もあります。
    
    一方、バージョン管理システムを用いると、一貫したルールに基づいた管理ができるようになります。特に、Gitをはじめ昨今主流となっているバージョン管理システムには、作業者が複数人いても、ファイルの最新状態や変更の履歴をわかりやすく保てる仕組みがあります。
    
    - ツールを使わない管理では、変更の履歴がわかりづらい
        - ツールを使わない管理はあとで面倒になります。
### 用語
- **バージョン**：アップデートするにつれて変化するファイルの状態のこと。
- **バージョン管理**：同じファイルの複数バージョンを保持すること。
- **Git**：ファイルのバージョン管理を行うためのツールで、多くのプロジェクトで使われている。</details>


**<details><summary>Lesson 02 [Gitの広がり]Gitの特徴を知りましょう</summary>**

Gitがどのようにして広がり、どんなことに使われているのかを見てみましょう。バージョン管理システムの用途の広さ、Gitならではの普及のきっかけに触れ、多くの人に使われるツールであることを知ってくださいね。
- はじまりはオープンソースソフトウェアの管理
    
    Linuxカーネルのソースコード管理システムとして、2005年に誕生したのがGitでした。開発したのはLinuxの開発者でもあるLinus Torvaldsで、Linuxカーネルの開発の手を止め、10日ほどでGitの基礎を作り上げました。大規模プロジェクトを高速に、そして複数人で並行して扱えるような仕組みを持っていることが大きな特徴です。
    
    ソースコードを含むプロジェクトの管理に用いることが多いですが、それ以外にも用途は多岐にわたっています。Wikiやブログなど、日本語で書くようなテキストも管理できますし、昨今では、ドイツが法令をGitで管理している事例もあります( https://github.com/bundestag/gesetze )。
    
    - Gitのさまざまな用途
        - プログラムのソースコード
        - WikiやブログなどのWebコンテンツ
        - 法令
        - 書籍の執筆
        
        Git自体もオープンソースソフトウェアです。「GNU General Public License」というライセンス形態を採用しており、ソフトウェアの利用や改変、再頒布などを許可しています。誰でも無償で使えることは、大きな広がりを見せている要因の1つでしょう。
        
- GitとGitHubの深い関係
    
    Gitが広まったきっかけの1つとして、GitHub(ギットハブ、https://github.com )の存在は無視できません。GitHubは、Gitの仕組みを利用して、インターネット上でのスムーズな共同作業を可能にしたWebサービスです。他のユーザーと簡単にコミュニケーションが取れる仕組みやプロジェクト管理に使える機能などもあり、いつでもどこでも効率よく開発が行えるメリットから、現在では広く普及しています。こうしたGitHubの勢いによる助けもあって、Gitは他のバージョン管理システムにはない広範囲な普及を成し遂げています。
    
    GitHubを運営しているGitHub本社はアメリカにあり、ページのほとんどが英語表記です。しかし、2015年に日本支社が設立され、昨今では日本での普及にもよりいっそう力が入っているようです。ちなみに、2018年に、GitHubはMicrosoftに買収されています。
    
    - GitHubの日本語紹介サイト
        - https://github.co.jp
    
    このChapterの残りのLessonでは、Gitを支える概念を解説します。ここでGitの全体像を掴んでおくことで、実際に操作をする際の理解の助けになり、応用しやすくなるはずです！
### 用語
- **オープンソースソフトウェア（Open Source Software）**：頭文字を取ってOSSと略されます。作成者がソースコードを無償で公開していて、利用や改変、再配布が自由に許可されているソフトウェアのことです。
    
    代表的なOSSには、オペレーティングシステムであるLinux、データベース管理システムのMySQL、プログラミング言語のJava、Perl、PHP、Python、WebブラウザのFirefoxなどがあり、さまざまな分野に広く用いられています。因みにGitもオープンソースソフトウェア。
    
    OSSは無償ながら、高性能かつ信頼性が高いものが多く知られており、企業が商用利用としてOSSを基に開発することも多くあります。特に、プログラミング言語や開発環境の分野には優秀なソフトウェアが多いため、OSSは開発者にとってなくてはならない存在といえます。
    
    OSSとは反対に、ソースコードへのアクセスや改変が制限されているソフトウェアを「プロプライエタリソフトウェア」といいます。一般的にソフトウェアのソースコードは知的財産となるため、ライセンス料を徴収して販売されています。多くの商用ソフトウェアは、プロプライエタリソフトウェアのため、ソースコードの改変はできません。
    
- **GitHub**：Gitの仕組みを利用して、インターネット上でのスムーズな共同作業を可能にしたWebサービス。</details>


**<details><summary>Lesson 03 [コミットの概要]変更を記録するコミットについて知りましょう</summary>**

Gitの特徴や役割を知る上で、バージョンの管理がポイントであることが理解できたでしょうか。このLessonでは、Gitでバージョンを扱う際の考え方と、まさにバージョンそのものを指す「コミット」という概念について説明します。
- ファイルの状態を記録に(コミット)していく
    
    Gitでは変更の履歴として、管理対象となっている全ファイルのその時点の状態を保存していきます。ユーザーが任意のタイミングで記録を保存する操作を「コミット」するといい、その記録自体のことも「コミット」と呼びます。コミットを連続して保存していくことでファイルの変更履歴がわかるようになるのが、Gitの基本的な仕組みなのです。
    
    また、ファイルの状態に加え、操作を行なったユーザーや時刻の情報も記録されます。それにより、「いつ」「誰が」「どんな変更を」したか後々誰が見てもわかるようになっています。そして、Gitで管理しているファイルは、いつでも過去のコミット時の状態へ戻したり、コミット間を行き来したりすることができます。
    
    - その瞬間の状態を繰り返し記録することで変更を管理する
        - コミット単位で行き来できる
- コミットの単位やタイミングは自由に決定できる
    
    コミットは自動的に行われません。ユーザーが適切なタイミングで明示的に実行する必要があります。いつ、どのような単位(区切り)でコミットするべきかは、扱うファイルの種類や、変更履歴を見直す頻度などを目安に判断します。
    
    たとえば、議事録や日記であれば、あとから何度も変更することはないので、コミットを工夫する必要はほとんどないかもしれません。一方、プログラムのソースコードとなると状況は変わります。あるプログラムに機能を追加していく時、「機能Aを追加したコミット」と「機能Bを追加したコミット」を分けておけば、履歴の行き来により「機能Aだけの状態」「機能Bだけの状態」などにあとから切り替えることも容易になります。また、コミットがきれいに分割されていることにより、他の人が履歴を追いやすくなります。
    
    - コミットの工夫で、履歴が追いやすくなる
        - プログラムに対する「機能の追加や変更」を単位としてコミットしていく例
            - 最初のバージョンを開発→コミット(記録)
                
                ↓
                
            - 機能Aを追加→コミット(記録)
                
                ↓
                
            - 機能Bを追加→コミット(記録)
                
                ↓
                
            - 機能Aの一部を変更した→(記録)
        
        最初はコミットの単位をうまく決められないかもしれません。慣れてくると、意味を持ったまとまりや、便利に扱いやすい単位でコミットすることを意識できるようになります。
        
- ワンポイント：コミットを指定するためのコミットハッシュ
    
    過去のコミットを行き来してファイルの状態を自在に切り替えられることがGitの特徴の1つですが、そのためには「どの」コミットの時点に戻りたいかを指定する必要があります。そこでGitで内部的に使われているのが、「コミットハッシュ」や「ハッシュ値」と呼ばれる文字列です。
    
    これは、コミットするときにSHA-1ハッシュ関数と呼ばれる計算式により割り出されるものです。1つひとつのコミットが全て異なる値を持つので、ハッシュ値を指定すればそこからコミットを特定できるというわけです。
    
    - コミットハッシュの例
        
        e3d43c66deb54e58237d718a04d688975bf1d4c2

### 用語
- **コミット：**①ユーザーが任意のタイミングで記録を保持する操作を「コミット」するといい、②その記録自体のことも「コミット」と呼びます。
- **コミットハッシュ**、**ハッシュ値**：コミットを特定するための文字列のこと。※文字列はゾロ目で揃えて綺麗にするのがマナーらしい。</details>


**<details><summary>Lesson 04 [リポジトリの概要]リポジトリの役割を理解しましょう</summary>**

このLessonではリポジトリの役割と種類について説明します。Gitの仕組みや使い方を学習する上で、リポジトリの理解は欠かせません。イラスト付きで解説していきますので、イメージを整理しながら読み進めてください。
- リポジトリはコミットの保管庫
    
    前のLessonで紹介したコミットをためていく場所を「リポジトリ」と呼びます。
    
    リポジトリを用意する方法には2つあります。まず、すでにGitで管理されているプロジェクトの開発に参加する場合は、リポジトリをコピー(Gitの用語では「クローン」)して使います。一方、新規でプロジェクトを立ち上げるような際は、リポジトリも新しく作成する必要があります。
    
    - リポジトリの作成方法
        
        リポジトリの作り方には、
        
        **①新たに作成する方法**
        
        **②既存のものをクローンする方法**
        
        があります。
        
- ローカルリポジトリとリモートリポジトリの違いをおさえよう
    
    リポジトリはローカルリポジトリとリモートリポジトリに分類できます。
    
    ローカルリポジトリは、手元で使っているパソコン内に作成する自分専用のリポジトリです。基本的に誰かと共同で使うことはありません。
    
    それに対してリモートリポジトリとは、インターネットなどのネットワーク上に存在するリポジトリのことです。複数人で共有するものとして、サーバー上に配備するのが一般的です。サーバーは自ら用意することも可能ですし、GitHubのようなホスティングサービスを用いることもあります。
    
    - ローカルリポジトリとリモートリポジトリ
        
        
        | ローカルリポジトリ | リモートリポジトリ |
        | --- | --- |
        | 手元のパソコン内 | ネットワーク上のサーバー内 |
        | 自分専用のローカルリポジトリ | 共同で使うリモートリポジトリ |
- 2種類のリポジトリを利用した共同作業の流れ
    
    多くの場合、1つのプロジェクトに、ローカルリポジトリとリモートリポジトリがそれぞれ1つ以上存在します。共同作業をする際は、複数人がそれぞれのローカルリポジトリで作業を行い、リモートリポジトリに反映させます。そして、別の作業者がそれをまた自分のローカルリポジトリに取得して作業を続けます。この繰り返しで進めていくのが一般的な共同作業の流れです。
    
    - ローカルリポジトリとリモートリポジトリを用いた作業の流れ
        
        ローカルリポジトリからリモートリポジトリに反映したコミットを、また別のローカルリポジトリへと反映することで共同作業を進めていく。
### 用語
- **リポジトリ**：コミット(記録)を貯めていく場所のこと。
    - **ローカルリポジトリ**：手元で使っているパソコン内に作成する自分専用のリポジトリ。基本的に誰かと共同で使うことはない。
    - **リモートリポジトリ**：インターネット上に存在するリポジトリのこと。複数人で共有するものとして、サーバー上に配備するのが一般的。
- **ホスティングサービス**：通信事業者が用意したサーバーをインターネットを介してレンタルするサービスのこと。</details>


**<details><summary>Lesson 05 [ローカルリポジトリの操作] ローカルリポジトリに対する操作のイメージをつかみましょう</summary>**

リポジトリについて、もう少し深く掘り下げます。これがわかると、このあとのLessonで行うGit操作の意味が格段に理解しやすくなります。しかし、もし難しいと感じた場合は、先にChapter2以降を読み進め、あとから戻ってくるという読み方をしてもかまいません。
- ローカルリポジトリにコミットを作成する
    
    コミットは、自分のパソコンで操作を行い、ローカルリポジトリ内に作成することがほとんどです。普段みなさんが行っている手順と同様にファイルを編集し、編集したものからコミットしたいものを選んでコミットする、というのが基本的な流れです。
    
    なお、Gitの管理対象はフォルダー単位で指定します。あるフォルダーをGitで管理すると決めたら、原則として、その中に含まれるすべてのファイルが(フォルダー内にさらにフォルダーがある場合はその中身も)管理対象となり、コミットを実行することによりリポジトリへ記録されます。
    
    - ローカルリポジトリではファイルを選んでコミットしていく
        
        Gitの管理対象としたフォルダーの中には.gitという隠しフォルダーが作られます。ここがローカルリポジトリの存在する場所です。ファイルの編集からコミットまで、1つのフォルダー内で完結することが分かりますね。
        
- 3つの場所をおさえよう
    
    先ほど紹介した基本的な流れを、Git用語を確認しながら詳しく見てみましょう。ローカルリポジトリにコミットを行いファイルの状態を保存するには、「ワークツリー」「ステージングエリア」「Gitディレクトリ」と呼ばれる3つの場所を用います。これらを使い分けることで、編集開始からコミット完了までの間、ファイルの状態を管理することができます。下の図は、「Gitで管理しているファイルを編集したあと、コミットを行う」シーンを例として、3つの場所の位置関係や使い方を表したものです。それぞれ、このあとのLessonで詳しく解説していくので、今は大まかな流れと関係を捉えておいてください。
    
    - 3つの場所を使ったコミットまでの流れ
        
        ワークツリー：編集を行う
        
        ↓
        
        ステージングエリア：コミットしたいファイルを登録
        
        ↓
        
        Gitディレクトリ：コミットする
        
- ワークツリーは変更するファイルを保持する場所
    
    Gitが保持している複数のコミットのうち、編集の開始地点となるのが「ワークツリー」です。「ワーキングツリー」「作業ディレクトリ」とも呼ばれます。ワークツリーにあるファイルは、最後にコミットした状態から手が加わっていない「unmodified(変更されていない)」な状態にあります。そこから何らかの編集をすると、ファイルは「modified(変更済み)」となります。
    
    尚、新規ファイルを作成した場合、そのファイルの状態はmodifiedではなく「untracked(追跡されていない)」です。また一度もコミットされたことのないファイルなので、Gitの管理下に置かれていないという意味でこの状態になります。
    
    - Git管理下のファイルに変更を加えると「modified」となる
        
        
        | Gitの管理外 | Gitの管理下 | Gitの管理下 |
        | --- | --- | --- |
        | 新規追加されたファイル |  | ファイルを編集 |
        | untracked(追跡されていない) | unmodified(変更されていない) | modified(変更済み) |
    
    ※「untracked」などの用語は、ファイルの状態を表しています。
    
- ステージングエリアはコミットするファイルを登録する場所
    
    ワークツリーでファイル編集を行った後、コミットしたい内容を一度ステージングエリアに登録します。modifiedなファイルの状態が「staged(ステージングエリアに追加済み)」へと変わります。また、untrackedなファイルをGitの管理下におきたいときも、ステージングエリアへの追加を行います。untrackedの直後に取りうる状態はstagedというわけですね。ステージングエリアという呼称が一般的ですが、「インデックス」と呼ぶこともあります。
    
    - ステージングエリアに追加後は「staged」となる
        
        
        | ワークツリー | ワークツリー | ステージングエリア |
        | --- | --- | --- |
        | untracked(追跡されていない) | modified(変更済み) | staged(追加済み) |
    
    ※ステージングエリアへの追加は手間だと思えるかもしれません。しかし、編集済みの箇所から追加したい部分だけを抜き出せるので、コミットの単位を操作しやすくなります。
    
- Gitディレクトリはコミットを格納する場所
    
    コミットを行うと、ステージングエリアに追加したファイルが、それ以降変更の入らないデータとしてGitディレクトリへ格納されます。原則として、一度コミットにより記録された内容は変更・削除されないものと思ってください。例えば仮に後からコミットを取り消す操作を行なっても、取り消す前後の状態がいずれも記録として残るので、コミット自体がなかったことにはなりません。
    
    コミットにより、ファイルの状態は再びunmodifiedとなります。作業が進行したにも関わらず状態が元に戻るようで違和感があるかもしれませんが、先程のワークツリーの説明を思い出してみてください。ポイントは、「最後にコミットした状態」から手が加わっていないのがunmodifiedであるということです。コミットした直後はまさにその状態であり、そこからまた編集やステージングエリアへの追加を行うことで、コミットから次のコミットまでのサイクルを回すことができるのです。
    
    - コミットすると「unmodified」の状態に戻る
        
        コミットされたファイルの状態はunmodified(最後のコミットから変更されていない)になる。
        
    
    ※管理対象のファイルが取りうる4つの状態とその行き来について理解できたでしょうか？Gitのコマンドを使っていて今何をしているのか分からなくなったら、ここで学んだイメージを時々見返してみることをお勧めします
### 用語
- **ワークツリー**：Gitが保持している複数のコミットのうち、編集の開始地点となる場所。「ワーキングツリー」「作業ディレクトリ」とも呼ばれる。
    - ワークツリーにあるファイルは、最後にコミットした状態から手が加わっていない「unmodified(変更されていない)」な状態にある。そこから何らかの編集をすると、ファイルは「modified(変更済み)」となる。
    - 新規ファイルを作成した場合、そのファイルの状態は「untracked(追跡されていない)」です。一度もコミットされたことのないファイルなので、Gitの管理下に置かれていないという意味でこの状態になります。
- **modified**：「最後にコミットした状態」から変更済みのファイルを表す。
- **unmodified**：「最後にコミットした状態」から変更されていないファイルを表す。
- **untracked**：追跡されていないファイルを表す。まだ一度もコミットされておらず、Gitの管理下にない。
- **ワークツリー**：編集の開始地点となる場所。変更するファイルを保持する場所。「ワーキングツリー」「作業ディレクトリ」とも呼ばれる。
- **ステージングエリア**：コミットするファイルを登録する場所。
- **Gitディレクトリ**：コミット(記録)を格納する場所。</details>


**<details><summary>Lesson 06 [リモートリポジトリの操作] リモートリポジトリに対する操作のイメージを掴みましょう</summary>**

リモートリポジトリは、ローカルリポジトリの内容を複数人で共有したり、バックアップしたりするために使います。覚えるべき操作はシンプルですが、共同作業ならではの難しさもあります。ここではその一部を紹介し、実践に入る前の最後の準備とします。
- リモートリポジトリを介し、コミットを共有し合う
    
    ローカルリポジトリにコミットした内容は、任意のタイミングでリモートリポジトリに反映させることが可能です。modified、stagedなどの状態にある、コミット前の内容は反映されません。
    
    リモートリポジトリ上のコミットも、いつでも自分のローカルリポジトリに取得可能です。チームで共同作業をしている場合は、他の人による変更を取り込むことができます。
    
- Gitには共同作業を進めやすくする機能が用意されている
    
    共同作業を可能にしてくれるリモートリポジトリはGitの重要な機能ですが、さまざまなリポジトリから変更を受け付けることで起こりうる問題もあります。イメージを掴むために、コンサートチケット予約のシステムの開発を例に考えてみましょう。新しい機能のリリーススケジュールがあり、機能ごとに担当チームが結成されているとします。もちろん、全てのソースコードはGitで管理されていると考えてください。六月中のある日、週目のリリースに向けた開発が先に終了しました。それに合わせ、追加した機能分の変更を、リモートリポジトリに反映させるとどうなるでしょうか。リリーススケジュールに反して、2周目用の変更が先に追加されてしまします。そんなとき便利なのが「ブランチ」という機能です。ブランチを活用することで、同じリポジトリで複数作業を平行して進め、任意の時点で反映できるようになります。ブランチについてはChapter 5から解説していきます。
    
- 変更の衝突が起きたら検知してくれる機能もある
    
    複数のチームが平行で進めていると、同じソースコードファイルの同じ箇所にそれぞれ違うコードを追加することもあります。それでは、互いの変更を取り込む際に、せっかく修正した箇所が相手チームの変更により上書きされてしまうような気がしませんか？
    
    しかしGitは、こうした変更の衝突を検知し、開発者に気付かせる「コンクリフト(競合)」と呼ばれる仕組みを持っています。共同作業ならではのトラブルのイメージが少しでも湧いたでしょうか？コンクリフトについてはChapter 7で解説します。
    
- ワンポイント Gitは1人でも便利に使うことができる
    
    Gitは複数人での作業に適していますし、本書の後半でもチーム開発に重点を置いた解説をしていきます。一方で、個人的な作業であってもGitは有効です。サービスやライブラリなどの開発用リポジトリとしてはもちろんのこと、新しい技術を学習する際のチュートリアルの実施記録を取ったり、ブログを書いたり、どんな使い方も可能です。どんどん使ってみましょう。
### 用語
- **ブランチ**：Gitで記録する履歴を枝分かれさせるための機能。
- **コンクリフト**：マージやリベース、プルなど、ブランチを統合する際に発生しうるもの。</details>

# Chapter 2 Gitを使う準備をしよう
この章では、インストールから設定まで、Gitを利用するために必要な環境の準備をしていきます。

<details><summary>Lesson 07 [環境を整える] パソコンにGitをインストールしましょう</summary>

ここからGitを利用するための環境を整えていきます。最初にインストールするのはGitのCUIクライアントです。Windows版とmacOS版があり、Windows版にはGit Bashというコマンド実行ツールが付属しています。
- Gitは「Gitクライアント」と「Gitサーバー」を使って操作する
    
    「クライアント」という言葉は、一般的に「顧客」や「依頼主」という意味で利用されていますね。
    
    IT用語での「クライアント」は、「サービスや機能の提供を受けるコンピューターやソフトウェア」のことを意味します。反対に、「サービスや機能を提供するコンピューターやソフトウェア」のことは「サーバー」と呼びます。「サーバーに対して何かを要求して、結果を受け取る」ためのコンピューターやソフトウェアを「クライアント」と考えましょう。
    
    Gitにも、GitサーバーとGitクライアントが存在します。Chapter 1で、複数人でコミットを共有し合うためのリモートリポジトリについて学びましたね。リモートリポジトリを動かしているソフトウェアのことを「Gitサーバー」と呼びます。一方、「Gitクライアント」はパソコンにインストールして「ローカルリポジトリを作る」「コミットする」「リモートリポジトリへコミットを反映する」など、Git操作を実行するために利用します。
    
    ※Gitサーバーは自分で構築することもできますし、GitHubのようなホスティングサービスを利用することもできます。
    
- 2種類のGitクライアント
    
    Gitクライアントには、CUIクライアントとGUIクライアントという2つの種類があります。
    
    CUIとは「Character User Interface」の略で、キーボードから文字の命令を入力してGitを操作します。
    
    GUIとは「Graphical User Interface」の略で、グラフィカルな画面上でマウスを使用してGitを操作します。
    
    CUIクライアントはとてもシンプルで、文字を入力するとその結果が文字で表示されます。GUIクライアントはメニューやボタンがたくさんあり、結果もグラフィカルに表示されます。本書では、文字入力のみでGitを操作できるCUIクライアントをお勧めします。GUIクライアントの方が視覚的に分かりやすいですが、種類が多く、それぞれ画面や操作方法が異なります。ツールによってできない操作設定があるため、本書では紹介するだけにとどめます。CUIクライアントを使うことで、「ツールの操作」ではなく「Gitの操作」を覚えることに集中できますし、Gitでの操作を全て利用できます。次のページからGitのCUIクライアントのインストール方法を解説していきます。
    
    ※GUIのほうがとっつきやすいですが、後々のことを考えてCUIに慣れておきましょう。
    
- Gitをインストールする(macOS)
    1. Gitのサイトを開く
        1. Gitのページ([https://git-scm.com/](https://git-scm.com/))を表示
        2. [Downloads]をクリック
    2. OSを選択する
        1. [macOS]をクリック
    3. インストール方法を選択する
        1. 最新バージョンをクリック ※本書では「Binary installer」を使用した手順を紹介します。
    4. ダウンロードが開始される
        1. 自動的にダウンロードが始まらない場合は、[Problems Downloading?]をクリックし、ミラーサイトからダウンロードしてください。
    5. ダウンロードしたdmgファイルを開く
        1. ダウンロードしたファイルをダブルクリック
    6. pkgファイルを開く
        1. pkgファイルをダブルクリック
        2. Point セキュリティに関する警告が表示された場合
            1. pkgファイルをダブルクリックした時に「開発元が未確認のため開けません」というメッセージが表示された場合は、controlキーを押しながらpkgファイルをクリックし、表示されたメニューの[開く]をクリックしましょう。
    7. インストールを開始する
        1. [続ける]をクリック
    8. インストールを実行する
        1. [インストール]をクリック
    9. インストールを完了する
        1. [閉じる]をクリック
- ワンポイント パッケージマネージャーを使ったインストール
    
    開発に使用するさまざまなツールをそれぞれのサイトからダウンロードしてインストールするのは面倒です。パッケージマネージャーを利用すると、コマンドラインでの共通の操作でさまざまなツールをインストールできます。さらに、最新版ではなく特定のバージョンを指定してインストールすることも可能です。例えば、Windowsでは「Chocolatey」( [https://chocolatey.org/](https://chocolatey.org/) )や「Scoop」( [https://scoop.sh/](https://scoop.sh/) )、Microsoft社のwinget( [https://docs.microsoft.com/ja-jp/windows/package-manager/winget/](https://docs.microsoft.com/ja-jp/windows/package-manager/winget/) )、macOSでは「Homebrew」( [https://brew.sh/index_ja](https://brew.sh/index_ja) )というパッケージマネージャーがあります。
### 用語
- **クライアント**：(IT用語では)サービスや機能の提供を受けるコンピューターやソフトウェアのこと。
- **サーバー**：(IT用語では)サービスや機能を提供するコンピューターやソフトウェアのこと。
- **Gitサーバー**：リモートリポジトリを動かしているソフトウェアのこと。
- **Gitクライアント**：パソコンにインストールして「ローカルリポジトリを作る」「コミットする」「リモートリポジトリへコミットを反映する」など、Git操作を実行するために利用するもので、CUIクライアントとGUIクライアントという2つの種類がある。
- **CUI**：「Character User Interface」の略で、キーボードから文字の命令を入力してGitを操作します。
- **GUI**：「Graphical User Interface」の略で、グラフィカルな画面上でマウスを使用してGitを操作します。</details>


<details><summary>Lesson 08 [コマンドの実行] コマンドを実行するツールを起動しましょう</summary>

CUIクライアントはキーボードから文字の命令を入力してGitを操作します。このようなコンピューターへの命令のことを「コマンド」といいます。まずはコマンドを実行するツールを起動しましょう。
- コマンドを実行するツールを知ろう
    
    Windowsでは「コマンドプロンプト」、macOSでは「ターミナル」というコマンド実行のためのCUIツールが標準で用意されています。しかし本書では、WindowsではWindows版Gitに付属するGit Bash(ギットバッシュ)をお勧めします。
    
    コマンドプロンプトとターミナルでは実行できるコマンドが異なるのですが、Git Bashを使えばWindowsでもmacOSのターミナルでもほとんど同じコマンドを実行できます。サーバーで用いられることが多いLinux(リナックス)と共通するコマンドも多いので、Windows独自のコマンドを覚えるよりも汎用性が高いです。
    
- ワンポイント Git Bashとターミナルで異なる部分
    
    Git Bashもターミナルも、「ユーザー名」「コンピューター名」「カレントディレクトリ」などが表示されていますが、その順番が下図のように異なります。最後に表示されている「$」をプロンプトと呼び、そのあとにコマンドを入力します。
    

**※本書では以降Git Bashの画面のみが掲載されますが、macOSのターミナルでも同じコマンドを実行できます。**
### 用語
- **カレントディレクトリ**：コマンドラインで開いている現在のディレクトリのこと。
- **Git Bash**：Windowsでコマンドを実行するためのツール。</details>


<details><summary>Lesson 09 [CUIの利用] CUIでフォルダーやファイルを操作する方法を身に付けましょう</summary>

続いてCUIからコマンドを実行してみましょう。先ずは、ファイルやフォルダー(ディレクトリ)を操作するための基本的なコマンドを試してみましょう。最後にGitコマンドでインストールしたGitのバージョンを確認します。
- コマンドラインとは何かを知ろう
    
    コマンドを入力する行のことをコマンドラインといいます。Windowsであれば「Git Bash」、macOSであれば「ターミナル」のコマンドラインに、コマンドを入力してさまざまな操作を実行します。
    
    本書では以下の構文でコマンドを記載します。「$」はプロンプトと呼び、コマンドラインの先頭に最初から表示されている文字なので、自分で入力する必要はありません。尚、コマンドは大文字/小文字を本書と同じように入力してください。大文字/小文字が異なると、コマンドを意図どおりに実行できません。
    

※コマンドやオプションは半角英数字で入力します。コマンドやオプションの間は、半角スペースを使用して区切ります。

- ディレクトリについて学ぼう
    
    CUIでは「ディレクトリ」という用語がよく登場しますが、これは「フォルダー」のことです。分かりやすさのためにほ書では、GUIによる操作の場合は「フォルダー」、CUIによる操作の場合は「ディレクトリ」と表記します。例えば、「Windowsのエクスプローラーから『フォルダー』を開く」「macOSのFinderから『フォルダー』を開く」「コマンドラインから『ディレクトリ』を開く」のように使い分けます。
    
    ディレクトリを操作するコマンドを説明する前に、名前を覚えてほしい特別なディレクトリが3つあります。「カレントディレクトリ」「ルートディレクトリ」「ホームディレクトリ」の3つです。「カレントディレクトリ」は、コマンドラインで開いている現在のディレクトリのことです。操作する場所を表すので状況によって変化します。「ルートディレクトリ」と「ホームディレクトリ」は下の図の通りです。
    
    - 3つのディレクトリ
        - ルートディレクトリ：一番階層が浅いディレクトリ
        - ホームディレクトリ：Git Bashなどを起動した時に初期表示されるディレクトリ
        - カレントディレクトリ：現在のディレクトリ

※「カレントディレクトリ」は「現在のディレクトリ」のことなので、他のディレクトリに移動すると、移動後のディレクトリが「カレントディレクトリ」になります。

- ファイルやディレクトリの位置を表す「パス」
    
    ファイルやディレクトリの位置を表す文字列を「パス」といいます。ファイルの位置を表したものは「ファイルパス」、ディレクトリの位置を表したものは「ディレクトリパス」と呼びます。
    
    先ほど紹介した3つの特別なディレクトリは、特別なパスが設定されています。
    
    - 特殊なディレクトリの記法
        
        
        | 表すもの | ディレクトリパス |
        | --- | --- |
        | カレントディレクトリ | 「.」(ドット) |
        | ホームディレクトリ | 「~」(チルダ) |
        | ルートディレクトリ | 「/」(スラッシュ) |
- 2種類のパスを覚えよう
    
    パスは「ルートディレクトリを起点としたパス」と「カレントディレクトリを起点としたパス」の2つの方法で指定できます。ルートディレクトリを起点としたパスを「絶対パス」、カレントディレクトリを起点としたパスを「相対パス」と呼びます。例えば、「ichiyasa」というディレクトリをカレントディレクトリとした時の絶対パスと相対パスは、次の図のようになります。そうたいパスでは、1つ上の階層のディレクトリは「..」(ドット2つ)というパスを使って指定します。
    
    - 絶対パスと相対パスの違い
        
        
        | 絶対パス | 相対パス |
        | --- | --- |
        | / 起点(ルートディレクトリ) | ../../../ |
        | /c | ../../ |
        | /c/Users | ../ |
        | /c/Users/ichiyasa | . 起点(カレントディレクトリ) |
        | /c/Users/ichiyasa/study | study |
        | /c/Users/ichiyasa/study/git | study/git |
        | /c/Program Files | ../../Program Files |
        | ルートディレクトリを起点に考える | カレントディレクトリを起点に考える |
- ディレクトリを操作するコマンドを知っておこう
    
    ディレクトリやファイルを操作する基本的なコマンドをいくつか紹介します。Gitのコマンドではありませんが、Gitでファイルを操作する場合に、よく使うものです。次ページの手順で実際に操作してみましょう。
    
    - ディレクトリを操作する基礎的なコマンド
        
        
        | コマンド | 働き |
        | --- | --- |
        | pwd | カレントディレクトリの絶対パスが出力される |
        | mkdir ディレクトリパス | 新しいディレクトリを作成する |
        | ls オプションディレクトリパス | ディレクトリの内容を確認する |
        | cd ディレクトリパス | カレントディレクトリを移動する |
    
    ※pwdコマンドやlsコマンドはWindowsの「コマンドプロンプト」では実行できません。
    
- オプションとパラメーターによってコマンドの結果が変わる
    
    コマンドの結果は、オプションとパラメーターの指定で変わります。例えば、ディレクトリの中を確認するlsコマンドに「-a」オプションをつけると、名前が「.」(ドット)で始まるファイルやディレクトリなどが表示されるようになります。先程学んだカレントディレクトリ「.」や1つ上の階層のディレクトリ「..」も表示されていますね。また、lsコマンドの後ろにパラメーターとしてディレクトリパスを付けると、カレントディレクトリ以外のディレクトリの中を確認できます。
    
- コマンドディレクトリを操作してみよう
    1. カレントディレクトリのパスを確認する
        1. カレントディレクトリのパスを確認するには、pwdコマンドを使います。pwdコマンドを実行すると、カレントディレクトリの絶対パスが出力されます。
        
        ```bash
        % pwd # カレントディレクトリのパスを確認
        /Users/yoshiwo
        ```
        
    2. 新しいディレクトリを作成する
        1. mkdirコマンドを使って、新しくstudyというディレクトリを作りましょう。mkdirコマンドの後ろに、新しく作るディレクトリパスを指定します。相対パスで指定すると、カレントディレクトリの中に新しいディレクトリが作成されます。
        
        ```bash
        % mkdir study # カレントディレクトリ内にstudyディレクトリが作成される
        ```
        
    3. 絶対パスでディレクトリを作成する
        1. mkdirコマンドのディレクトリパスには絶対パスも使用できます。絶対パスは環境によって異なるので、「ichiyasa」の部分は使用している環境のホームディレクトリを書いてください。
        
        ```bash
        % mkdir /Users/yoshiwo/study/git # studyディレクトリ内にgitディレクトリが作成される
        ```
        
        ※Point macOSの場合は？
        
        絶対パスは次のように指定すること。
        
        ```bash
        % mkdir /Users/yoshiwo/study/git
        ```
        
    4. ディレクトリに何が入っているかを確認する
        1. lsコマンドを使って、カレントディレクトリの中に、どのようなディレクトリやファイルが入っているのか確認してみましょう。
        
        ```bash
        % ls # カレントディレクトリ内にあるディレクトリやファイルを表示する
        Applications	Documents	Library		Music		Public		codes		mysql		study		update
        Desktop		Downloads	Movies		Pictures	TwitterHeader	exit		ruby-book	test
        ```
        
    5. 全てのファイルとディレクトリを表示する
        1. lsコマンドに-aオプションを付けると、lsコマンドだけでは見えなかった全てのファイルが表示されます。先程の結果と見比べてみましょう。
        
        ```bash
        % ls -a # 全てのファイルとディレクトリを表示する
        .			.bundle			.ssh			Applications		Pictures		study
        ..			.config			.viminfo		Desktop			Public			test
        .CFUserTextEncoding	.gitconfig		.vscode			Documents		TwitterHeader		update
        .DS_Store		.irb_history		.zsh_history		Downloads		codes
        .Trash			.local			.zsh_sessions		Library			exit
        .atom			.mysql_history		.zshr			Movies			mysql
        .bash_profile		.rbenv			.zshrc			Music			ruby-book
        ```
        
    6. 他のディレクトリに何が入っているか確認する
        1. lsコマンドの後ろにディレクトリパスを付けると、そのディレクトリパスが指すディレクトリの中身が表示されます。カレントディレクトリを移動せずに他のディレクトリの内容が確認できて便利です。
        
        ```bash
        % ls Documents # 他のディレクトリに何が入っているか確認する
        MyVSCodeProject
        ```
        
    7. カレントディレクトリを移動する
        1. 初期状態で表示されているのはホームディレクトリです。先程作成した「study」ディレクトリに移動してみましょう。cdコマンドの後ろにディレクトリパスを付けることで、他のディレクトリに移動できます。移動したらpwdコマンドでカレントディレクトリを確認しましょう。
        
        ```bash
        % cd study # studyディレクトリに移動
        % pwd # pwdコマンドでカレントディレクトリを確認
        /Users/yoshiwo/study # カレントディレクトリが絶対パスで表示される
        ```
        
    8. 1つ上の階層のディレクトリに移動する
        1. 1つ上の階層のディレクトリに移動したい場合は、相対パスの「../」を使用します。
        
        ```bash
        % cd ../ # ../で1つ上の階層のディレクトリに移動する
        % pwd
        /Users/yoshiwo # ホームディレクトリに移動したことが確認できる
        ```
        
- Gitのバージョンを確認しよう
    
    本書ではgitという文字から始まるコマンドのことをGitコマンドと呼びます。
    
    Gitコマンドは、Gitをインストールしていないと使用できないので注意してください。Gitコマンドについては次のChapter 3から本格的に解説していきます。
    
    1. Gitのバージョンを確認する
        1. git - -versionを実行して、インストールしたGitのバーションを確認してみましょう。バージョン番号が表示されたら、Gitのインストールに成功しています。
        
        ```bash
        % git --version # Gitのバージョンを確認
        git version 2.33.0
        ```
        
- ワンポイント Gitのコマンドにはサブコマンドがある
    
    Gitの多くのコマンドは「git」のあとに半角スペースを空けて「config」や「add」などのサブコマンドを書き、そのあとにオプションなどが続く形式になります。
    
    ```bash
    $ git config --list # git=コマンド config=サブコマンド --list=オプション
    ```

### 用語
- **コマンドライン**：コマンドを入力する行のこと。
- **$(プロンプト)**：プロンプトと呼び、コマンドラインの先頭に最初から表示されている文字。
- **ディレクトリ**：フォルダー(ファイルを保管する場所)のこと。
- **フォルダー**：ファイルを保管する場所のこと。
- **ルートディレクトリ**：一番階層が浅いディレクトリ
- **ホームディレクトリ**：Git Bashなどを起動した時に初期表示されるディレクトリ
- **カレントディレクトリ**：現在のディレクトリ
- **パス**：ファイルやディレクトリの位置を表す。
- **ファイルパス**：ファイルの位置を表したもの。
- **ディレクトリパス**：ディレクトリの位置を表したもの。
- **絶対パス**：ルートディレクトリを起点としたパス。
- **相対パス**：カレントディレクトリを起点としたパス。
- **pwd**：カレントディレクトリの絶対パスが出力される。
- **mkdir ディレクトリパス**：新しいディレクトリを作成する。
- **ls オプションディレクトリパス**：ディレクトリの内容を確認する。
- **cd ディレクトリパス**：カレントディレクトリを移動する。
- **pwdコマンド**：カレントディレクトリ(現在のディレクトリ)の絶対パス(ルートディレクトリを起点としたパス)が出力される。
- **mkdirコマンド**：新しくディレクトリ(フォルダー)を作成する。
- **lsコマンド**：カレントディレクトリ内のファイルとディレクトリが表示される。
- **lsコマンドに-aオプションを付ける**：全てのファイルとディレクトリを表示する。
- **cdコマンド**：cdコマンドの後ろにディレクトリパスを付けることで、他のディレクトリに移動できる。
- **../**：1つ上の階層のディレクトリに移動する。
- **Gitコマンド**：gitという文字から始まるコマンドのこと。</details>


<details><summary>Lesson 10 [エディターのインストール] Visual Studio Codeをインストールしましょう</summary>

初期設定では、Gitは「Vim」(ビム)というエディターを利用してメッセージなどを編集します。しかし、「Vim」は利用までに覚えることが多いため、本書では「Visual Studio Code」エディターをオススメします。

- 「Visual Studio Code」エディターとは
    
Gitではコミット時のメッセージ入力などにテキストエディターを使用します。Windowsでは「メモ帳」、macOSでは「テキストエディット」というテキストエディターがデフォルトでインストールされていますが、より高機能なテキストエディターを利用することをオススメします。「Visual Studio Code」はMicrosoft社が主体となって、オープンソースで開発している無料のテキストエディターです。複数ファイルに対する検索や、シンタックスハイライトというテキストを色分けして表示する機能など、便利な機能がたくさん付いています。
    
- Visual Studio Codeをインストールする(macOS)
    1. ファイルとダウンロードする
        1. Visual Studio Codeのページ( [https://code.visualstudio.com/](https://code.visualstudio.com/) )を表示
        2. [Download Mac Universal]をクリック
    2. アプリケーションフォルダーへファイルを移動する
        1. ダウンロードしたファイルを「アプリケーション」フォルダーへ移動
    3. Visual Studio Codeを起動する
        1. 「アプリケーション」フォルダーに移動した[Visual Studio Code]をダブルクリック
    4. コマンドラインから呼び出せるようにする
        1. shift + command + Pキーを押す
        2. 「shell」と入力
        3. [シェルコマンド：PATH内に'code’コマンドをインストールします]をクリック
        4. OKをクリック
### 用語
Visual Studio Code：Microsoft社が主体となって、オープンソースで開発している無料のテキストエディター。複数ファイルに対する検索や、シンタックスハイライトというテキストを色分けして表示する機能など、便利な機能がたくさん付いている。</details>


<details><summary>Lesson 11 [拡張子の表示] ファイルの拡張子を表示しましょう</summary>

このLessonでは、ファイルの拡張子を表示します。WindowsやmacOSでは、初期設定では拡張子が表示されません。しかし、Gitでは拡張子付きの名前でファイルを操作する必要があります。設定して、ファイルの拡張子が見えるようにしましょう。

- ファイルの拡張子
    
    拡張子は、ファイルがどのような種類のファイルなのかを表すものです。ファイルの名前は「ファイル名.拡張子」という構成で表記します。ファイル名がindex.htmlやsample.pngであれば、「.」(ドット)の後ろのhtmlやpngが拡張子となります。GUIクライアント(WindowsのエクスプローラーやmacOSのFinder)では、初期設定でファイルの拡張子を表示しない設定になっています。しかし、CUIクライアントでは標準で拡張子が表示され、拡張子をつけないと同じファイルとみなされません。GUIでも拡張子を表示するように設定して、ファイルの見え方をGUIクライアントとCUIクライアントで合わせておきましょう。
    
    - 本書に登場する拡張子の種類
        
        
        | 拡張子 | ファイルの種類 |
        | --- | --- |
        | html | HTMLファイル |
        | png | PNG画像ファイル |
        | css | CSSファイル |
        | md | Markdownファイル |
        
        ※Markdownファイルとは、Markdownという形式で記述したテキストファイルのことで、拡張子は「.md」が使われます。Markdownについては、Chapter 3で説明します。
        
- ファイルの拡張子を表示する(macOS)
    1. 拡張子を表示する設定をする
        1. Finderを開き、[Finder] - [環境設定]をクリック
        2. [詳細]タブをクリック
        3. [全てのファイル名拡張子を表示]にチェックマークを付ける
### 用語
拡張子：ファイルがどのような種類のファイルなのかを表すもの。ファイルの名前は「ファイル名.拡張子」という構成で表記される。</details>


<details><summary>Lesson 12 [初期設定] Gitの設定をしましょう</summary>

最後にGitの設定をすれば、Gitを使う準備は全て完了です。ユーザー名やメールアドレスをGitに設定して、誰がこのGitを使っているのかがわかるようにしましょう。また、使用するエディターなども設定します。

- Gitの設定をするgit configコマンド
    
    Gitの設定をするにはgit configというコマンドを利用します。- -globalオプションを付けることで、ホームディレクトリの.gitconfigというファイルに設定が保存されていきます。また、設定の確認もできます。
    
    - Gitの設定をするコマンド
        
        ```bash
        $ git config --global user.name ichiyasa-g-2 # git config=git configコマンド --global=--globalオプション
        # user.name=設定項目名 ichiyasa-g-2=設定値
        ```
        
    - 設定値の一覧を確認する
        
        ```bash
        $ git config --list # --list=--listオプション
        ```
        
    - 特定の設定値を確認する
        
        ```bash
        $ git config user.name # user.name=設定を確認したい項目名
        ```
        
        ※この設定は、必ず実施しましょう！
        
- ユーザー名とメールアドレスを登録する
    
    最初にユーザー名とメールアドレスを登録しましょう。登録したユーザー名とメールアドレスはコミットに記録され、誰がコミットしたかを明らかにすることができます。将来的にリポジトリを複数人で共有する際、ここで設定したユーザー名とメールアドレスがリモートリポジトリのアカウントと紐付けられることが多いです。そのため、適当な値を設定するのではなく、公開しても問題ない自身のメールアドレスと設定しましょう。
    
    1. ユーザー名を設定する
        1. ユーザー名を登録するには、git configコマンドの設定項目名をuser.nameとします。ここでは「ichiyasa-g-2」をユーザー名に設定していますが、実際に使用するものへ置き換えて入力してください。
            
            **※Gitでのユーザー名**
            
        
        ```bash
        % git config --global user.name yoshiwo.may15
        # 忘れた場合はここで確認すること
        ```
        
    2. メールアドレスを設定する
        1. 続いてuser.emailを指定してメールアドレスを設定します。ここでは「ichiyasa-g-2@example.com」としていますが、実際に使用するものへ置き換えて入力してください。
            
            **※Gitでのメールアドレス**
            
        
        ```bash
        % git config --global user.email yoshiwo.may15@gmail.com
        # 忘れた場合はここで確認すること
        ```
        
    3. 設定内容を確認する
        1. 設定を確認するには、git configコマンドに- -listオプションを付けて実行します。設定項目が一覧で表示されるので、先程登録したuser.nameとuser.emailの値を確認してみましょう。
        
        ```bash
        % git config --list # 設定項目が一覧で表示される
        core.excludesfile=~/.gitignore
        core.legacyheaders=false
        core.quotepath=false
        mergetool.keepbackup=true
        push.default=simple
        color.ui=auto
        color.interactive=auto
        repack.usedeltabaseoffset=true
        alias.s=status
        alias.a=!git add . && git status
        alias.au=!git add -u . && git status
        alias.aa=!git add . && git add -u . && git status
        alias.c=commit
        alias.cm=commit -m
        alias.ca=commit --amend
        alias.ac=!git add . && git commit
        alias.acm=!git add . && git commit -m
        alias.l=log --graph --all --pretty=format:'%C(yellow)%h%C(cyan)%d%Creset %s %C(white)- %an, %ar%Creset'
        alias.ll=log --stat --abbrev-commit
        alias.lg=log --color --graph --pretty=format:'%C(bold white)%h%Creset -%C(bold green)%d%Creset %s %C(bold green)(%cr)%Creset %C(bold blue)<%an>%Creset' --abbrev-commit --date=relative
        alias.llg=log --color --graph --pretty=format:'%C(bold white)%H %d%Creset%n%s%n%+b%C(bold blue)%an <%ae>%Creset %C(bold green)%cr (%ci)' --abbrev-commit
        alias.d=diff
        alias.master=checkout master
        alias.spull=svn rebase
        alias.spush=svn dcommit
        alias.alias=!git config --list | grep 'alias\.' | sed 's/alias\.\([^=]*\)=\(.*\)/\1\     => \2/' | sort
        include.path=~/.gitcinclude
        include.path=.githubconfig
        include.path=.gitcredential
        diff.exif.textconv=exif
        credential.helper=osxkeychain
        user.name=username #ユーザー名
        user.email=emailaddress # メールアドレス
        init.defaultbranch=main
        ```
        
        **※もし設定した値が間違っている場合は、手順1または手順2をもう一度実行しましょう。**
        
- **Point** git configの結果が途中までしか表示されないとき
    
    git configコマンドで設定の一覧を確認していてウィンドウに結果が表示しきれないときは、ウィンドウの一番下に「:」(コロン)が表示された状態になります。このとき、キーボードの上下キーを押すことでウィンドウの表示をスクロールできます。表示をやめるときはQキーを押すとコマンドラインに戻ります。
    
- 利用するエディターを設定する
    
    Gitの操作でメッセージを入力することがあります。ここではメッセージの入力時に先程インストールしたVisual Studio Codeがエディターとして開くように設定しましょう。他のエディターを利用したい場合は、手順1の"code”の部分に利用したいエディターのexeファイルのパスを設定してください。
    
    1. Visual Studio Codeを設定する
        
        ```bash
        % git config --global core.editor "code --wait"
        # インストール時に、Visual Studio Codeをcodeという名前でパソコンのPATHに登録しています
        ```
        
    2. 設定を確認する
        1. git configコマンドの後ろに設定項目名を入力すると設定した値を確認できます。core.editorの値を確認してみましょう。
        
        ```bash
        % git config core.editor # git configコマンドの後ろに設定項目名を入力
        code --wait # core.editorにcodeが設定されていることを確認
        ```
        
- **Point** 設定を削除したい場合は
    
    Gitに登録した設定項目を削除する場合は--unsetオプションに設定項目名を指定して実行します。
    
    ```bash
    $ git config --global --unset 設定項目名
    ```
    
- **ワンポイント** リモートリポジトリと接続できない場合のプロキシ設定
    
    会社などの内部ネットワークからインターネットに接続する場合、プロキシサーバーというサーバーを経由することがあります。皆さんが会社でGitを利用しており、リモートリポジトリと接続できないという問題が発生した場合、プロキシサーバーが原因かもしれません。
    
    その場合は、Gitにプロキシサーバーの設定をする必要があります。
    
    - プロキシ環境でGitを利用する場合の設定
        
        ```bash
        $ git config --global http.proxy http://example.com:8080
        # http://example.com:8080=プロキシサーバーURL:ポート番号
        ```
        
    - プロキシに認証が必要な場合
        
        ```bash
        $ git config --global http.proxy http://username:password@example.com:8080
        # http://username:password@example.com:8080=プロキシのユーザー名:パスワード@プロキシサーバーURL:ポート番号
        ```
        
- **ワンポイント** 標準ブランチ名の設定
    
    Gitのバージョン2.28からgit configコマンドのオプションにdefaultBranchが追加されました。このオプションを使うとリポジトリを作った時にできる「ブランチ」の名前を設定できます。(「ブランチ」はChapther 5を参照)
    
    Windowsの場合はGitをインストールした時にmasterが設定されています。Windows以外を使っている場合はdefaultBranchをmasterに設定しましょう。この設定はいつでも変更できます。
    
    ```bash
    $ git config --global init.defaultBranch master # master=デフォルトブランチの名前
    ```
    
### 用語
- **git configコマンド**：Gitの設定を行う。
- **--globalオプション**：ホームディレクトリの.gitconfigというファイルに設定が保存される。
- **git config --list**：設定項目が一覧で表示される。
- **exeファイル**：米マイクロソフト（Microsoft）社のWindowsで用いられる実行可能プログラムのファイル形式の一つ。ファイル名の標準の拡張子が「.exe(エグゼ)」であることからこのように呼ばれる。
- **--unsetオプション**：変数や関数を削除する。
- **プロキシサーバー**：プロキシ（Proxy）は英語で「代理」の意味。インターネットに直接接続できないコンピューターに代わり、インターネットに接続し、Webサイトへのアクセスなどを行うサーバーのことを指す。ホームページを見るときに使うソフト（Webブラウザ）の身代わりになってホームページにアクセスしてくれるコンピュータのこと。
- **ブランチ**：Gitで記録する履歴を枝分かれさせるための機能。複数の作業を並行して進める時に使用する。詳細はChapter 5にて。</details>


<details><summary>Lesson 13 [GUIクライアントの紹介] GUIクライアントを知りましょう</summary>

これまでコマンドを使ってファイルとフォルダーの操作やGitの設定をしてきました。本書では今後もコマンドを使って操作していきますが、コマンドでの操作に慣れない方のためにGUIクライアントについても紹介します。

- コマンドに慣れない場合はGUIクライアントを使おう
    
    本書ではCUIクライアントとコマンドを使って解説をしてきますが、「どうしてもCUIの操作になじめない……」と感じる人もいるかと思います。そういう場合は、無理をせずGUIクライアントを試してみてください。ファイルやフォルダーの操作には、WindowsのエクスプローラーやmacOSのFinderを利用してかまいません。大切なのは使うツールではなく、Gitで何ができるのかを理解し、実際にバージョン管理ができる状態になることです。GitのGUIクライアントはたくさんあり、GitのGUIクライアントの紹介ページでも多くのツールが紹介されています。きっと使いやすいツールが見つかるはずです。
    
- Git操作専用ツール
    
    GitのGUIクライアントの紹介ページに掲載されているツールは、ほぼこのカテゴリに当てはまります。有名なものに、Atlassian社が提供している「Sourcetree」( [https://www.sourcetreeapp.com/](https://www.sourcetreeapp.com/) )やGitHub社が提供している「GitHub Desktop」( [https://desktop.github.com/](https://desktop.github.com/) )などがあります。
    
- エディターや統合開発環境(IDE)のプラグイン
    
    先程インストールしたMicrosoft社の「Visual Studio Code」や、Sublime社の「Sublime Text」( [https://www.sublimetext.com/](https://www.sublimetext.com/) )、JetBrains社が提供している「IntelliJ IDEA」などの各種IDE( [https://www.jetbrains.com/](https://www.jetbrains.com/) )といった高機能エディターやIDEには、Gitを操作するためのプラグインが用意されています。これらを利用すると「プログラミングをして、作っているプログラムをGitでバージョン管理する」までを1つのツールで行えるので便利です。
    
- Gitに組み込まれているGUIツール
    
    GitにもGUIツールが付属しており、gitkやgit guiなどのコマンドで起動します。gitkは過去のコミットを確認できるツールで、git guiはコミットを作成するためのツールです。どちらも、次のChapterでローカルリポジトリを作ってから実行してください。
### 用語
- **gitk**：過去のコミットを確認できるツール。
- **git gui**：コミットを作成するためのツール。</details>

# Chapter 3 ファイルをバージョン管理してみよう
準備がすべて終わったので、いよいよ本格的にGitの操作をしていきます。ローカルリポジトリを作って、実際にコミットの作成までやってみましょう。

<details><summary>Lesson 14 [Gitコマンドの概要] ローカルリポジトリでの操作を知りましょう</summary>

このChapter全体を通して、ローカルリポジトリに対する操作を学んでいきます。覚えなければいけないことは多いですが、これを覚えれば自分専用のローカルリポジトリでバージョン管理をするために必要なGitの知識を身に付けられます。

- ローカルリポジトリでの操作を知ろう
    
    Gitを実際に使い始める前に、このChapterで何を学ぶのかを整理しておきましょう。
    
    たくさんあるように感じますが、使用頻度が高くて最低限覚える必要があるのはステージングエリアへの登録(git add)とコミットの作成(git commit)を行うコマンドです。その他に、現在の状態を確認するコマンド(git status)もよく使います。少しずつ使えるコマンドを増やしていきましょう。
    
- このChapterで使用するコマンド
    1. リポジトリの作成
        1. git init…………ローカルリポジトリを作成する
    2. コミットの作成
        1. git add…………ステージングエリアに変更を登録する
        2. git commit……コミットを作成する
        3. git rm……………Git管理下のファイルやディレクトリを削除する
    3. 状態の復元
        1. git checkout…ワークツリーの変更を取り消す
        2. git reset………ステージングエリアに追加した変更をワークツリーへ戻す
    4. 状態の確認
        1. git status……ローカルリポジトリの状態を確認する
        2. git diff…………各エリアの差分を確認する
        3. git log…………コミットの履歴を確認する
- ローカルリポジトリを作成する
    
    git initコマンドを実行すると、そのディレクトリにローカルリポジトリが作られます。
    
    この作業だけでGitでバージョン管理をするための準備は完了し、ディレクトリに配置したファイルはuntracked(追跡されていないファイルを表す。まだ一度もコミットされておらず、Gitの管理下にない)という状態になります。ファイルはすべてワークツリーに配置されてしまうので、Gitで管理したくないファイルは.gitignoreファイルを作成して、ファイルを指定します。
    
- コミットするためのコマンド
    
    ワークツリーに配置されたファイルは、git addコマンドでステージングエリアに登録し、git commitコマンドでコミットします。
    
    それぞれのエリアの状況がわからなくなったときは、git statusコマンドやgit diffコマンド、git logコマンドなどで状態を確認できます。
### 用語
- **git add**：ステージングエリアへの登録を行う。
- **ステージングエリア**：コミットするファイルを登録する場所。
- **git commit**：コミットの作成。
- **git status**：現在の状態を確認する。
- **git init**：ローカルリポジトリを作成する。
- **.gitignore**：Gitで管理したくないファイルを.gitignoreファイルを作成してファイルを指定する。
- **git diff**：各エリアの差分を確認する。
- **git log**：コミットの履歴を確認する。</details>


<details><summary>Lesson 15 [ローカルリポジトリの作成] ローカルリポジトリを作りましょう</summary>

このLessonでは、ローカルリポジトリを実際に作っていきましょう。先ずディレクトリを作ってMarkdown形式のファイルを配置します。そして、そのディレクトリにローカルリポジトリを作成します。作成後はその状態を確認しましょう。

- ローカルリポジトリを作成するには
    
    本書ではMarkdownファイル(P.79参照)に学習した内容をメモして、そのファイルをバージョン管理しながらGitを学んでいきます。先ずはホームディレクトリに「ichiyasa」ディレクトリを作成し、そこに「Git_MEMO.md」というMarkdownファイルを保存します。「idhiyasa」ディレクトリにローカルリポジトリを作成したら、いったんその状態を確認してみましょう。
    
- Gitで管理するファイルを用意する
    1. 「ichiyasa」ディレクトリを作成する
        1. Git Bash(macOSではターミナル)を起動して、ホームディレクトリに「ichiyasa」ディレクトリを作ります。Chapter 2で解説したディレクトリ移動のcdコマンドと、ディレクトリ作成のmkdirコマンドを使いましょう。
        
        ```bash
        % cd ~ # ホームディレクトリに移動
        % mkdir ichiyasa # 「ichiyasa」ディレクトリを作成
        ```
        
    2. 「Git_MEMO.md」ファイルを作成する
        1. Visual Studio Codeを起動し、テキストファイルを作成し、「ichiyasa」ディレクトリに保存しましょう。その際、Markdownファイルは文字コードを「UTF-8」にしてください。「UTF-8」以外だとMarkdown用のビューワーなどで表示したときに文字化けする場合があります。Visual Studio Codeを使用していればデフォルトの文字コードは「UTF-8」になりますが、別のエディターを使用している場合は、文字コードに「UTF-8」を設定するように注意してください。
            1. Visual Studio Codeを開く
            2. ファイルタグから、新しいテキストファイルを選択
            3. 本書の内容を入力して、command + S を押す
            4. Finderが開くので、「ichiyasa」フォルダーを選択、ファイル名を「Git_MEMO.md」とする
            5. 保存をクリック
- 「ichiyasa」ディレクトリにローカルリポジトリを作ろう
    
    ローカルリポジトリには.gitというディレクトリが自動生成されています。ls -aコマンドで、ディレクトリの存在を確認してみましょう。
    
    1. ローカルリポジトリを作成する
        1. 先程作成した「ichiyasa」ディレクトリに移動して、ローカルリポジトリを作成します。git initコマンドを実行してみましょう。標準設定ではこのコマンドによってmasterという名のブランチが作られます(ブランチについてはChapter 5参照)。
        
        ```bash
        % cd ichiyasa # 「ichiyasa」ディレクトリに移動
        ichiyasa % git init # 「ichiyasa」ディレクトリにローカルリポジトリを作成
        Initialized empty Git repository in /Users/yoshiwo/ichiyasa/.git/ # Usersディレクトリの中のyoshiwoディレクトリの中のichiyasaディレクトリの中に.gitという初期化された空のGitリポジトリ(ローカルリポジトリ)
        ```
        
    2. ディレクトリ内を確認する
        1. lsコマンドでディレクトリの中にあるものを表示してみましょう。-aオプションで非表示ディレクトリも表示します。
        
        ```bash
        % ls -a # カレントディレクトリ以外のディレクトリやファイルを表示
        .		..		.git		Git_MEMO.md # (左から)起点カレントディレクトリ→Users→.gitディレクトリ→Git_MEMO.mdファイル
        ```
        
        - **Point** ローカルリポジトリの内容
            
            git initコマンドを実行すると、先程作成した「Git_MEMO.md」ファイルと別に、「.git」というディレクトリが自動作成されます。「.git」ディレクトリにはGitの情報が保管されているので削除してはいけません。
            
- ローカルリポジトリの状態を確認しよう
    
    ディレクトリに置いたファイルはワークツリーに配置されていることになります。その状態を確認してみましょう。ローカルリポジトリの状態を確認するには、git statusコマンドを実行します。
    
    ```bash
    % git status # ローカルリポジトリの状態を確認
    On branch main
    
    No commits yet
    
    Untracked files: # 登録されていないファイルは「Untracked files」という扱いになる
      (use "git add <file>..." to include in what will be committed)
    	Git_MEMO.md
    
    nothing added to commit but untracked files present (use "git add" to track)
    ```
    
    - **Point** git statusコマンドの実行結果の見方
        
        git statusコマンドの結果を見てみましょう。現時点では「Git_MEMO.md」ファイルを作成しただけなので、Gitの管理下にはファイルが登録されていません。**登録されていないファイルは「Untracked files」という扱いになる**ので、「Untracked files:Git_MEMO.md」と表示されています。
        
- git statusの結果の例
    
    ```bash
    On branch master # ブランチについての情報
    
    No commits yet # 一度もコミットしていない場合に表示される
    
    Untracked files: # untracked(追跡されていない)なファイルを表す
      (中略)
           Git_MEMO.md
    ```
    
    ```bash
    On branch master # ブランチについての情報
    
    No commits yet # 一度もコミットしていない場合に表示される
    
    Changes to be commited: # staged(ステージングエリアに追加済み)のファイルを表す
      (中略)
           new file:    Git_MEMO.md
    ```
    
    ```bash
    On branch master # ブランチについての情報
    Changes not staged for commit:
      (中略)
           modified:    Git_MEMO.md # modified(変更済み)のファイルを表す
    ```
    
    ```bash
    On branch master # ブランチについての情報
    nothing to commit, working tree clean # すべてコミットされ、その後に変更したファイルがないunmodified(変更されていない)状態を表す
    ```
    
- **ワンポイント** Markdownで構造を持つ文章を書こう
    
    Markdownは「見出し」や「段落」「箇条書き」などの構造を持つ文章を書くためのファイル形式です。オープンソースのソフトウェアの多くは、説明のためにREADME.mdなどのMarkdownファイルを添付しています。HTMLよりもシンプルな記述ルールになっており、手軽に構造を持つ文章を書けます。
    
    Markdownで記載した文章はそのままでもテキストエディターで読めますが、変換ツールを使用してMaikdownをHTMLやPDFにしたり、Markdown用のビューワーを使用したりすれば、より読みやすくなります。Visual Studio CodeにもMarkdownのビューワー機能がついており、command + K + V で表示できます。
### 用語
- **Markdown**：「見出し」や「段落」「箇条書き」などの構造を持つ文章を書くためのファイル形式のこと。
- **lsコマンド**：ディレクトリの中を確認する。lsコマンドの後ろにパラメーターとしてディレクトリパスを付けるとカレントディレクトリ以外のディレクトリの中を確認できる。
- **ls -a**：lsコマンドの後ろに-aオプションを付けるとファイルやディレクトリも表示される。
- **ワークツリー**：変更するファイルを保持する場所。「ワーキングツリー」「作業ディレクトリ」とも呼ぶ。
- **git statusコマンド**：ローカルリポジトリの状態を確認。</details>


<details><summary>Lesson 16 [ステージングエリアへの登録] ステージングエリアに登録しましょう</summary>

いよいよ、バージョン管理を実践していくLessonに入りました。最初のステップとして、先程作成した「Git_MEMO.md」をステージングエリアに登録します。パスの指定次第では、複数のファイルを同時に登録することもできます。

- ファイルをステージングエリアに登録しよう
    
    「Git_MEMO.md」ファイルをステージングエリアに登録してみましょう。ステージングエリアとは、コミットするファイルを登録する場所のことでしたね。ステージングエリアへファイルを登録するには、git addコマンドを使います。
    
    コマンドの後にファイルやディレクトリのパスを書くと、指定したファイルや指定したディレクトリ配下のファイルをステージングエリアに登録できます。
    
    - ステージングエリアに登録するコマンド
        
        ```bash
        $ git add Git_MEMO.md # git add=git addコマンド、Git_MEMO.md=ファイルパスまたはディレクトリパス
        ```
        
- ファイルやディレクトリの便利な指定方法を知ろう
    
    ファイルの数が多い場合に1つずつファイルを指定したり、カレントディレクトリに登録したいファイルがない場合にわざわざ移動したりするのは大変ですよね。そのようなときのために、相対パスの使い方に慣れておきましょう。git addコマンドにファイルパスを指定した場合はそのファイルだけが登録されますが、ディレクトリパスを指定した場合はディレクトリは以下のファイル全てを登録できます。このルールを覚えておけば、ファイル指定は簡単になります。
    
    - git addコマンドの利用例
        1. カレントディレクトリ配下の全てのファイルを追加
            
            ```bash
            $ git add . 
            ```
            
        2. 「subDirectory」ディレクトリ配下の全てのファイルを追加
            
            ```bash
            $ git add subDirectory
            ```
            
        3. 「subDirectory」ディレクトリ配下のfile1.mdを追加
            
            ```bash
            $ git add subDirectory/file1.md
            ```
            
- ファイルをステージングエリアに登録する
    1. git addコマンドでステージングエリアに登録する
        1. git addコマンドを使って「Git_MEMO.md」ファイルをステージングエリアに登録しましょう。ここでは相対パスで指定します。絶対パスも利用できますが、相対パスの方が簡単です。
        
        ```bash
        $ git add Git_MEMO.md
        ```
        
        ※git addコマンドで指定した相対パスが間違っている場合は、「fatal; pathspec ’ファイル名’ did not match any files」と表示されます。
        
    2. ステージングエリアに登録されたことを確認する
        1. git statusコマンドでローカルリポジトリの状態を確認してみましょう。実行結果を見てみると、「Git_MEMO.md」の分類が「Untracked files:」から「Changes to be committed:」に変わっていますね。「Git_MEMO.md」の前に「new file:」と書かれており、「Git_MEMO.md」が新しいファイルとしてステージングエリアに登録されたことがわかります。
        
        ```bash
        yoshiwo@Yoshiwos-MacBook-Pro ichiyasa % git status # 現在の状態を確認する
        On branch main
        
        No commits yet
        
        Changes to be committed:
          (use "git rm --cached <file>..." to unstage)
        	new file:   Git_MEMO.md
        ```

### 用語
- **ステージングエリア**：コミットするファイルを登録する場所。
- **git addコマンド**：ステージングエリアにファイルを登録する。
- **ディレクトリパス**：ディレクトリの位置を表したもの。
- **git add .**：カレントディレクトリ配下の全てのファイルを追加できて便利。
- **git status**：現在の状態を確認する。</details>


<details><summary>Lesson 17 [ファイルの差分確認] ファイルの差分を確認しましょう</summary>

ファイルの修正前と修正後の違いを「差分」といいます。差分を見て意図しない変更がないか確認することはとても重要です。このLessonでは、ワークツリーとステージングエリアや、ステージングエリアとGitディレクトリの差分を確認する方法を紹介します。

- ファイルの差分を確認する方法を知ろう
    
    ファイルの差分の確認方法も学びましょう。差分の確認にはgit diffコマンドを使用します。このコマンドによって様々な差分を確認できますが、今回は代表的な使い方を紹介します。まず、git diffコマンドに何もオプションをつけずに実行すると、ワークツリーとステージングエリアの差分を確認できます。そして--cachedオプションを付けるとステージングエリアとGitディレクトリの差分を確認できます。
    
- ファイルの差分を確認してみよう
    1. ファイルの差分を確認する準備をする
        1. では、実際に差分を確認する準備として、「Git_MEMO.md」ファイルを変更しましょう。この変更によって、ステージングエリアに登録した状態とワークツリーの状態が変わります。
    2. ワークツリーとステージングエリアの差分を確認する
        1. git diffコマンドを実行して、ワークツリーとステージングエリアの差分を確認してみましょう。追加した行は先頭に「+」が付いた緑色の文字で表示され、削除した行は先頭に「-」(マイナス)が付いた赤色の文字で表示されます。
        
        ```bash
        $ git diff # 各エリアの差分を確認する
        $ git diff --cached # ステージングエリアとGitディレクトリの差分を確認できる
        
        ichiyasa % git diff
        diff --git a/Git_MEMO.md b/Git_MEMO.md
        index 2a3fcae..66d3497 100644
        --- a/Git_MEMO.md
        +++ b/Git_MEMO.md
        @@ -1,2 +1,5 @@
         # Git学習メモ
        -## Gitコマンド
        \ No newline at end of file
        +## Gitコマンド
        +
        +- ローカルリポジトリを作る
        +      - git init
        \ No newline at end of file
        ```
        
        - **Point** 改行を追加すると行が変更されたとみなされる
            
            実行結果を見てみると、「Git_MEMO.md」ファイルの2行目の「## Gitコマンド」は、文章を変えていないのに行が削除されたことを意味する赤文字で表示されていますね。これは、2行目の文末に改行が追加されているので、「## Gitコマンド(改行なし)」という行が削除されて、「## Gitコマンド(改行あり)」という行が追加されたと見做されるためです。
            
    3. ステージングエリアとGitディレクトリの差分を確認する
        1. 続いて、git diffコマンドに--cachedオプションをつけて実行しましょう。コマンドを実行するとステージングエリアとGitディレクトリ(前回のコミット)の差分が表示されます。まだ一度もコミット実行していないので、ステージングエリアのファイルに書かれている行だけが表示されています。ワークツリーでの変更はステージングエリアに登録前なので、こちらの結果には表示されていませんね。
        
        ```bash
        $ git diff --cached # ステージングエリアとGitディレクトリの差分を確認できる
        
        ichiyasa % git diff --cached
        diff --git a/Git_MEMO.md b/Git_MEMO.md
        new file mode 100644
        index 0000000..2a3fcae
        --- /dev/null
        +++ b/Git_MEMO.md
        @@ -0,0 +1,2 @@
        +# Git学習メモ
        +## Gitコマンド
        \ No newline at end of file
        ```
        
- **ワンポイント** テキストファイルとバイナリファイル
    
ファイルは大きく分けて、文字のデータだけが格納されている「テキストファイル」と、それ以外の多くの情報を持つ「バイナリファイル」の2種類があります。テキストファイルは、Windowsの「メモ帳」やmacOSの「テキストエディット」、「Visual Studio Code」などで表示できるファイルが当てはまります。このLessonで編集しているMarkdownファイルはテキストファイルに当てはまります。バイナリファイルは、画像ファイルやMicrosoft Excelファイルのような、専用のアプリケーションで開く形式のファイルです。Gitではテキストファイルとバイナリファイルの両方をバージョン管理できます。しかし、Gitの機能を最大限に活用できるファイルはテキストファイルです。例えばバイナリファイルではgit diffコマンドでファイルの差分を確認できません。
### 用語
- **差分**：ファイルの修正前と修正後の違いを指す。
- **git diffコマンド**：各エリアの差分を確認する。
- **git diff --cached**：ステージングエリアとGitディレクトリの差分を確認できる。
- **git init**：ローカルリポジトリを作成する。
- **テキストファイル**：文字のデータだけが格納されているファイルのこと。例)Windowsの「メモ帳」、macOSの「テキストエディット」、「Visual Studio Code」などで表示できるファイル。
- **バイナリファイル**：文字のデータ以外の多くの情報を持つファイルのこと。例)画像ファイル、Microsoft Excelファイルのような専用のアプリケーションで開く形式のファイル。</details>


<details><summary>Lesson 18 [コミットする] ファイルをコミットしましょう</summary>

それではファイルをコミットしてみましょう。コミットには、「そのコミットがどういう内容なのか」を説明するコミットメッセージを書きます。このLessonでは、エディターを使ってコミットする方法と、より素早くコミットする方法の2つを紹介します。

- ローカルリポジトリにコミットしよう
    
    ステージングエリアに登録している「Git_MEMO.md」ファイルをコミットしましょう。コミットするには、git commitコマンドを利用します。
    
    コミットする際に、そのコミットでの変更内容を説明するコミットメッセージを書く必要があります。コマンドを実行すると、登録しておいたテキストエディター(本書ではVisual Studio Code)が開きます。コミットメッセージを書くとコミットが完了します。
    
    ※コミットメッセージを「日本語で書くか、英語で書くか」「1行で書くか、複数行で書くか」などは、チームの方針に合わせましょう。
    
- 「Git_MEMO.md」ファイルをコミットする
    
    まずは複数行のコミットメッセージを書いてコミットしてみましょう。コミットメッセージを書いてファイルを保存し、Visual Studio Codeを閉じると、コミットが完了します。
    
    1. ローカルリポジトリの状態を確認する
        
        ```bash
        $ git status # 現在の状況を確認する
        
        yoshiwo@Yoshiwos-MacBook-Pro ichiyasa % git status
        On branch main
        
        No commits yet # まだコミットしていない
        
        Changes to be committed: # Git_MEMO.mdがステージングエリアに登録されている
          (use "git rm --cached <file>..." to unstage)
        	new file:   Git_MEMO.md
        
        Changes not staged for commit:
          (use "git add <file>..." to update what will be committed)
          (use "git restore <file>..." to discard changes in working directory)
        	modified:   Git_MEMO.md
        ```
        
    2. コミットを実行する
        
        ```bash
        $ git commit
        
        yoshiwo@Yoshiwos-MacBook-Pro ichiyasa % git commit
        hint: Waiting for your editor to close the file...
        ```
        
    3. Visual Studio Codeが開く
        
        ![スクリーンショット 2022-07-29 17.01.27.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b4e15c9e-f3bb-4683-9f9c-251b76a0a44b/_2022-07-29_17.01.27.png)
        
        ※先頭が「#」の行はコメント行です。コミットメッセージには反映されません。
        
    4. コミットメッセージを書く
        
        ![スクリーンショット 2022-07-29 17.07.44.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/edb96ff0-6237-499e-8f3e-be06e11bf657/_2022-07-29_17.07.44.png)
        
        1. 1行目に要約(コミットタイトル)をかく
        2. 2行目は空白行
        3. 3行目以降に詳細を書く
        4. 書き終わったらファイルを保存してVisual Studio Codeを閉じる
    5. コミットが完了する
        1. Visual Studio Codeを閉じると、コミットが完了し、結果がコマンドラインに表示されます。
        
        ```bash
        # コミットメッセージのタイトルや、追加したファイルの情報が表示されます
        [main (root-commit) 2da8208] Gitの学習メモを作成
         1 file changed, 2 insertions(+)
         create mode 100644 Git_MEMO.md
        ```
        
    6. ローカルリポジトリの状態を確認する
        
        ```bash
        $ git status
        
        # ステージングエリアにあったGit_MEMO.mdは表示されなくなる
        # ワークツリーのGit_MEMO.mdはそのまま表示されています
        yoshiwo@Yoshiwos-MacBook-Pro ichiyasa % git status
        On branch main
        Changes not staged for commit:
          (use "git add <file>..." to update what will be committed)
          (use "git restore <file>..." to discard changes in working directory)
        	modified:   Git_MEMO.md
        
        no changes added to commit (use "git add" and/or "git commit -a")
        ```
        
- **Point** オススメのコミットメッセージの形式
    
    コミットメッセージは1行で簡潔に書くことも、複数行を使って詳細を書くこともできます。
    
    複数行で書く場合は1行目に変更内容を要約した短い文章を書き、2行目を空白行にして3行目以降に詳細な説明を書く方法が、Gitの公式サイトに書かれているオススメの書き方です(参考：[https://git-scm.com/docs/git-commit#_discussion](https://git-scm.com/docs/git-commit#_discussion))。複数行で書いた場合は、1行目の内容がコミットタイトルして扱われます。
    
- コミットメッセージが1行の時に素早くコミットする
    
    コミットメッセージが1行の場合はVisual Studio Codeを開かずに素早くコミットできます。「Git_MEMO.md」を変更してステージングエリアに登録し、-mオプションを利用してコミットしてみましょう。
    
    1. 「Git_MEMO.md」ファイルを変更する
    2. ファイルをステージングエリアに登録する
        
        ```bash
        $ git add Git_MEMO.md
        
        ichiyasa % git add Git_MEMO.md
        ```
        
    3. ステージングエリアの状態を確認する
        
        ```bash
        $ git status
        
        ichiyasa % git status
        On branch main
        Changes to be committed:
          (use "git restore --staged <file>..." to unstage)
        	modified:   Git_MEMO.md
        # ステージングエリアに登録されている
        ```
        
    4. ファイルをコミットする
        1. git commitコマンドに-mオプションを付けると、コマンドラインから直接コミットメッセージを指定できます。コミットメッセージは「"」(ダブルクォーテーション)で囲みましょう。
        
        ```bash
        $ git commit -m "ローカルリポジトリの作成とステータスの確認コマンドを記載"
        
        ichiyasa % git commit -m "ローカルリポジトリの作成とステータスの確認コマンドを記載"
        [main 9c379b8] ローカルリポジトリの作成とステータスの確認コマンドを記載
         1 file changed, 6 insertions(+), 1 deletion(-)
        # コミットされて結果が表示される
        ```
        
    5. ステータスを確認する
        1. 変更を全てコミットすると、ステータスを確認してもファイルは表示されなくなります。その代わりに「nothing to commit, working tree clean(コミットすべきものは何もない、ワークツリーはクリーンだ)」と表示されます。
        
        ```bash
        $ git status
        
        ichiyasa % git status
        On branch main
        nothing to commit, working tree clean
        # コミットしていないファイルがないことを意味するメッセージが表示される
        ```
        
- **Point** コミットされるのはその時点でのファイルの状態
    
今回は「Git_MEMO.md」を2回コミットしましたが、そこに疑問を感じる人もいるかもしれませんね。コミットされるのは、git addコマンドでステージングエリアに登録した時点のファイルです。登録後にワークツリーで行った変更は含まれていません。新しい変更をステージングエリアに登録するためには、もう一度git addコマンドを実行する必要があります。
### 用語
- **git commitコマンド**：コミットを作成する(ファイルはステージングエリアからGitディレクトリに移動する(コミット(記録)される))。
- **コミットメッセージ**：コミットで加えた変更内容を説明するテキスト。
- **git commit -m**：コマンドラインから直接コミットメッセージを指定できる。この時、コミットメッセージは「"」ダブルクォーテーションで囲むこと。
- **ワークツリー**：Gitが保持している複数のコミットのうち、編集の開始地点となる場所。「ワーキングツリー」「作業ディレクトリ」とも呼ばれる。
- **ステージングエリア**：コミットするファイルを登録する場所。
- **Gitディレクトリ**：コミット(記録)を格納する場所。</details>


<details><summary>Lesson 19 [操作を取り消す] ローカルリポジトリでの操作を取り消しましょう</summary>

不要な変更をしていることに気がついて最後のコミットまで状態を戻したくなったり、誤ってステージングエリアに登録したものを取り消したくなったりすることがあります。このLessonでは、そのような変更を取り消す方法を2つ紹介します。

- 変更を取り消したくなるシチュエーションとは？
    
    ここまでにステージングエリアへの登録など、コミットするまでの一連の流れを説明してきました。しかし、ファイルを間違えて登録してしまった場合など、変更を取り消したくなることもあるかと思います。このLessonでは、ワークツリーへの変更を取り消す方法(git checkoutコマンド)と、ステージングエリアへの変更を取り消す方法(git resetコマンド)について紹介します。ワークツリーへの変更の取り消しでは、ファイルの状態が直前のコミット(または直前のステージングエリアへの登録)に戻ります。ステージングエリアへの変更の取り消しは、ファイルの状態はそのままでステージングエリアへの登録だけを取り消します。
    
    ※変更の取り消しといっても、エディターの「元に戻す」機能とは違います。
    
- git checkoutコマンドでワークツリーの変更を取り消す
    
    ファイルを色々と変更してしまったけれど、やっぱり直前にコミットした状態まで戻したくなった場合は、git checkoutコマンドを使ってワークツリーの変更を取り消せます。
    
    Chapter 5でも説明しますが、このコマンドはパラメーターにブランチ名を指定するとブランチを切り替えられます。今回のようにブランチ名ではなく「--」(ハイフン2つ)を指定すると、「直前のコミットの状態に戻す」という働きをします。
    
- **ワンポイント** git checkoutコマンドで取り消せないケース
    
    git checkoutコマンドで操作を取り消せない場合もあります。代表的なケースは、ファイルを新規作成したときやファイル名を変更したときです。ファイルを新規作成したときはファイルがそのまま残ってしまします。また、ファイル名を変更したときは、変更前のファイルと変更後のファイルの両方が残ってしまいます。どちらのケースも不要なファイルは自分で削除します。
    
- **ワンポイント** 新しく追加されたgit restoreとgit switchコマンド
    
    git checkoutコマンドはワークツリーの変更を取り消す以外にも、特定のコミットにワークツリーの状態を切り替えたり、ブランチの作成や切り替えができたりと、ひとつのコマンドで色々な操作ができます。多くの操作ができるのは便利ですがわかりづらくもあります(ブランチについてはChapter 5で紹介します)。
    
    そのため、よりわかりやすい役割分担のために導入されたのがgit restoreコマンドとgit switchコマンドです。git restoreコマンドを使うとワークツリーやステージングエリアの変更を取り消せます。そして、git switchコマンドを使うとブランチを切り替えられます。それぞれのコマンドでできることが少ないので、役割が明確でシンプルです。
    
    2つのコマンドはまだ正式版ではなく実験的にリリースされている状態であり、今度使い方が変更される可能性もあるので、本書では主にgit checkoutコマンドを使って解説します。しかし、git statusコマンドを実行した時に変更を取り消すヒントとして既にgit restoreコマンドが表示されていることから、今後は新しいコマンドの利用が推奨されていくと思います。そのため、どちらも試せるように、必要と思われる箇所では新しいコマンドを使う場合の方法も記載します。
    
- 「Git_MEMO.md」ファイルへの変更を取り消す
    1. 「Git_MEMO.md」ファイルを変更する
        
        ```bash
        # Git学習メモ
        ## Gitコマンド
        
        - ローカルリポジトリを作る
              - git init
        - ファイルの状態を確認
              - git status
        - ファイルを登録する # この2行を追記してファイルを上書き保存
              - git add
        ```
        
    2. ワークツリーの状態を確認する
        1. 一旦git statusコマンドを実行して、ワークツリーの状態を確認しておきましょう。
        
        ```bash
        $ git status
        
        ichiyasa % git status
        On branch main
        Changes not staged for commit: # ステージングエリアに登録されていない変更が表示される
          (use "git add <file>..." to update what will be committed)
          (use "git restore <file>..." to discard changes in working directory) # ワークツリーディレクトリの変更を捨てるためにgit restore <file>を使用せよ
        	modified:   Git_MEMO.md
        
        no changes added to commit (use "git add" and/or "git commit -a")
        ```
        
        ※ステータスを確認した時、「use "git restore <faile>...” to discard changes in working directory」(ワークツリーの変更を捨てるには「git restore <file>」を使え)と表示されています。このように、Gitは操作のヒントを表示してくれることがあります。本書では次ページの方法で変更の取り消しを行いますが、どちらの方法でも構いません。
        
    3. ワークツリーの変更を取り消す
        
        ```bash
        $ git checkout -- Git_MEMO.md
        
        ichiyasa % git checkout -- Git_MEMO.md
        # git restore Git_MEMO.mdでも同じことができる
        ```
        
    4. ワークツリーの状態を確認する
        
        ```bash
        $ git status
        
        ichiyasa % git status
        On branch main
        nothing to commit, working tree clean # ワークツリーにはコミットしていないファイルがない、と表示
        ```
        
    5. ファイルを確認する
        
        ```bash
        # Git学習メモ
        ## Gitコマンド
        
        - ローカルリポジトリを作る
              - git init
        - ファイルの状態を確認
              - git status
        # ファイルは最後にコミットした状態へ戻っている(2行を付け加える前の状態)
        ```
        
        ※厳密にいうと、git checkoutコマンドは最後にコミットした状態ではなく、ステージングエリアの状態に戻すコマンドです。ステージングエリアにファイルの状態が登録されたままになっていると想定通りの動作になりませんそのような場合は、次で学ぶgit resetコマンドを使いましょう。
        
- ステージングエリアへの登録を取り消す
    
    間違ってファイルの状態をステージングエリアに登録してしまった時には、git resetコマンドを使って操作を取り消せます。先程学んだgit checkoutコマンドとは異なり、ワークツリー内のファイルの変更は取り消されません。下図のコマンドでは、git resetコマンドの後ろにHEADと指定していますね。
    
    HEADは、このローカルリポジトリで最後にコミットした状態を意味しています。ステージングエリアの状態を最後のコミットと同じ状態にリセットするという意味になります。
    
    - ステージングエリアへの登録を取り消すコマンド
        
        ```bash
        $ git reset HEAD Git_MEMO.md
        # git reset=git resetコマンド
        # HEADは最新のコミットを指す
        # Git_MEMO.md=ファイルパスまたはディレクトリパス
        ```
        
- **ワンポイント** git resetコマンドの働き
    
    git resetコマンドには、コミットをなかったことにする機能もあります。しかし、コミット自体に手を加えると様々な問題を引き起こすことがあるので、なるべく避けたほうがいいでしょう。
    
    コミットした内容を取り消したいときは、ファイルを以前の状態に修正して新しく「取り消すためのコミット」を追加しましょう。
    
- ステージングエリアへの登録を取り消す
    1. 「Git_MEMO.md」ファイルを変更する
        
        ```bash
        # Git学習メモ
        ## Gitコマンド
        
        - ローカルリポジトリを作る
              - git init
        - ファイルの状態を確認
              - git status
        - ファイルを登録する # この2行を追記してファイルを上書き保存
              - git add
        ```
        
    2. ファイルをステージングエリアに登録する
        
        ```bash
        $ git add Git_MEMO.md
        
        ichiyasa % git add Git_MEMO.md
        ```
        
    3. ローカルリポジトリの状態を確認する
        
        ```bash
        $ git status
        
        ichiyasa % git status
        On branch main
        Changes to be committed:
          (use "git restore --staged <file>..." to unstage)
        	modified:   Git_MEMO.md
        ```
        
        ステージングエリアに登録されたことを確認しましょう。メッセージを見ると「use "git restore --staged <file>..." to unstage」(アンステージにするには「git reset HEAD <file>...」を使え)と表示されています。
        
    4. ステージングエリアへの登録を取り消す
        
        ```bash
        $ git reset HEAD Git_MEMO.md
        
        ichiyasa % git reset HEAD Git_MEMO.md # git restore --staged Git_MEMO.mdでも同じことができます。
        Unstaged changes after reset: # リセットによってGit_MEMO.mdがunstagedされたと表示されています
        M	Git_MEMO.md
        ```
        
    5. ローカルリポジトリの状態を確認する
        
        ```bash
        $ git status
        
        ichiyasa % git status
        On branch main
        Changes not staged for commit: # Git_MEMO.mdはステージングエリアに登録されていないと表示される
          (use "git add <file>..." to update what will be committed)
          (use "git restore <file>..." to discard changes in working directory)
        	modified:   Git_MEMO.md
        
        no changes added to commit (use "git add" and/or "git commit -a")
        ```
        
    6. 「Git_MEMO.md」ファイルを確認する
        
        ```bash
        # Git学習メモ
        ## Gitコマンド
        
        - ローカルリポジトリを作る
              - git init
        - ファイルの状態を確認
              - git status
        - ファイルを登録する # ファイルの内容は変更後の状態のままです
              - git add
        ```
        
        ※ファイルの内容も変更前に戻したい場合は、先程紹介したgit checkoutコマンドを使いましょう。
### 用語
- **git checkoutコマンド**：ワークツリーへの変更を取り消す。ブランチを作る。ブランチを切り替える。コミットした状態に切り替える。と、ひとつのコマンドで色々な操作ができる。一方で多いがためにわかりづらい側面もある。
    - **git checkout --**：直前のコミットの状態に戻す。
- **git reset**：ステージングエリアに追加した変更をワークツリーへ戻す(git add(ステージングエリアにファイルを登録する)を取り消す)。
- **git restoreコマンド**：ワークツリーやステージングエリアの変更を取り消すことができる。
- **git switchコマンド**：ブランチを切り替えられる。
- **ブランチ**：Gitで記録する履歴を枝分かれさせるための機能。複数の作業を並行して進める時に使用する。
- **git reset HAED**：ステージングエリアの状態を最後のコミットと同じ状態にリセットする。この時のHAEDは、ローカルリポジトリで最後にコミットした状態を意味する。</details>


<details><summary>Lesson 20 [ファイルを削除する] Gitの管理下にあるファイルを削除しましょう</summary>

Gitの管理下にあるファイルは、エクスプローラーなどで削除しただけでは不十分です。削除をステージングエリアに登録し、コミットしなければいけません。git rmコマンドを使うと、ファイルの削除とステージングエリアへの登録をコマンド1つで実行してくれます。

- Git管理下のファイルを削除しよう
    
    git rmコマンドはGitで管理しているファイルやディレクトリを削除するためのコマンドです。このコマンドを実行すると、ワークツリーからファイルやディレクトリを削除し、削除した状態をステージングエリアに登録します。その後でコミットすると削除作業が完了します。
    
    ※エクスプローラーやFinderでファイルやディレクトリを削除した場合は、git addコマンドを使って「ファイルを削除した状態」をステージングエリアに登録してください。git rmコマンドはそれらをまとめてやってくれるコマンドです。
    
- ディレクトリを削除するときは書き方が異なる
    
    ディレクトリを削除するにはgit rmコマンドに-rオプションを指定します。-rとはrecursive(再帰的)の略で、「指定したディレクトリの中にあるファイルやディレクトリに対して、削除の処理を繰り返し実行する」という意味を持ちます。-rオプションをつけないと中身があるディレクトリを削除できません。
    
    - ファイルやディレクトリを削除するコマンド
        
        ```bash
        $ git rm remove_me.txt
        # git rm = git rmコマンド
        # remove_me.txt = ファイルパス
        ```
        
        ```bash
        $ git rm -r subDirectory
        # -r = -rオプション
        # subDirectory = ディレクトリパス
        ```
        
        ※ディレクトリを削除するときは、-rオプションを忘れないようにしましょう。
        
- 不要なファイルをわざと追加して削除する
    
    git rmコマンドの使い方を学ぶために、次ページの手順では一旦不要なファイル(remove_me.txt)を作成します。それをコミットした後、git rmコマンドで削除してみましょう。
    
    - 次ページで行う作業
        1. 作成する
            1. ワークツリーにremove_me.txtファイルが作られる。
        2. 登録する
            1. ステージングエリアにremove_me.txtファイルが登録される。
        3. コミット
            1. Gitディレクトリにremove_me.txtファイルがコミット(記録)される。
        4. 削除する
            1. remove_me.txtファイルを削除してワークツリーに登録する。
            2. 削除したremove_me.txtファイルをステージングエリアに登録する。
        5. コミットする
            1. Gitディレクトリに削除したremove_me.txtファイルを登録する。
- 「remove_me.txt」ファイルを用意する
    1. 削除するファイルを作成する
        1. Visual Studio Codeを起動してファイルを新規作成し、「remove_me.txt」という名前で保存します。削除を試すためのものなので中身は入力しません。
            1. ファイルタグから「新しいテキストファイル」をクリック→ファイルタグから「名前を付けて保存…」をクリック
            2. Finderが開くので、ファイル名を「remove_me.txt」という名前に、保存する場所は「Git_MEMO.md」と同じディレクトリにすること。今回の場合は「ichiyasa」という名前のディレクトリ。
    2. ファイルをステージングエリアに登録する
        
        ```bash
        $ git add remove_me.txt
        
        yoshiwo@Yoshiwos-MacBook-Pro ichiyasa % git add remove_me.txt
        ```
        
    3. ファイルをコミットする
        
        ```bash
        $ git commit -m "削除対象のファイルを作成"
        # git commitコマンドに-mを付けると、コマンドラインから直接コミットメッセージを指定できる
        # このとき指定するメッセージは「"」ダブルクォーテーションで囲むこと
        
        yoshiwo@Yoshiwos-MacBook-Pro ichiyasa % git commit -m "削除対象のファイルを作成"
        [main eda8205] 削除対象のファイルを作成
         1 file changed, 0 insertions(+), 0 deletions(-)
         create mode 100644 remove_me.txt
        ```
        
    4. ディレクトリにあるファイルを確認する
        
        ```bash
        $ ls
        
        yoshiwo@Yoshiwos-MacBook-Pro ichiyasa % ls
        Git_MEMO.md	remove_me.txt # 「remove_me.txt」ファイルが存在していることを確認
        ```
        
- 「remove_me.txt」ファイルを削除する
    1. ファイルを削除する
        
        ```bash
        $ git rm remove_me.txt
        
        yoshiwo@Yoshiwos-MacBook-Pro ichiyasa % git rm remove_me.txt
        rm 'remove_me.txt'
        ```
        
    2. ディレクトリにあるファイルを確認する
        
        ```bash
        $ ls
        
        yoshiwo@Yoshiwos-MacBook-Pro ichiyasa % ls
        Git_MEMO.md # 「remove_me.txt」ファイルが削除されていることがわかる
        ```
        
        ※git rmコマンドでファイルを削除してもコミットされたわけではありません。コミットしないとバージョン管理されないので、git rmコマンドの実行後にコミットすることを忘れないようにしましょう。
        
    3. ファイルの状態を確認する
        
        ```bash
        $ git status
        
        yoshiwo@Yoshiwos-MacBook-Pro ichiyasa % git status
        On branch main
        Changes to be committed:
          (use "git restore --staged <file>..." to unstage)
        	deleted:    remove_me.txt # 「remove_me.txt」ファイルの状態がdeletedとしてステージングエリアに登録されている
        
        Changes not staged for commit:
          (use "git add <file>..." to update what will be committed)
          (use "git restore <file>..." to discard changes in working directory)
        	modified:   Git_MEMO.md
        ```
        
    4. ファイルを削除したことをコミットする
        
        ```bash
        $ git commit -m "remove_me.txtファイルを削除する" # git commit -mでコマンドラインから直接コミットメッセージを指定できる
        
        yoshiwo@Yoshiwos-MacBook-Pro ichiyasa % git commit -m "remove_me.txtファイルを削除する"
        [main 642aeee] remove_me.txtファイルを削除する #削除したことがコミットされる
         1 file changed, 0 insertions(+), 0 deletions(-)
         delete mode 100644 remove_me.txt
        ```
        
- **ワンポイント** 改行コードの警告
    
    git addコマンドの実行結果に「warning: LF will be replaced by CRLF in ファイル名」という警告が表示されることがあります。
    
    これは、Gitのインストール次に指定した改行コードの設定が影響しており(P.37参照)、改行コードを「LF」で保存したファイルが、「CRLF」に変換されることがあると警告しています。ファイルの改行コードを変換したくない場合は、P.63で学んだgit configコマンドでcore.autocrifの設定をfalseにしましょう。
### 用語
- **git rmコマンド**：Gitで管理しているファイルやディレクトリを削除するためのコマンド。
- **git rm -r**：git rmに-rオプションを指定すると、「指定したディレクトリの中にあるファイルやディレクトリに対して、削除の処理を繰り返し実行する」という意味を持つ。-rはrecursive(再帰的(コンピューターで、ある作業中に、さらに同じ作業を呼び出して処理すること))の略。
- **git addコマンド**：ステージングエリアにファイルを登録する。
- **git commitコマンド**：コミットを作成する(ファイルはステージングエリアからGitディレクトリに移動する(コミット(記録)される))。
- **git commit -m**：コマンドラインから直接コミットメッセージを指定できる。この時、コミットメッセージは「"」ダブルクォーテーションで囲むこと。
- **lsコマンド**：カレントディレクトリ内のファイルとディレクトリが表示される。</details>


<details><summary>Lesson 21 [Gitで管理しないファイルを設定] Gitで管理しないファイルを設定しましょう</summary>

Gitで管理すべきではないファイルも存在します。そういうファイルはステージングエリアへ登録しないようにしましょう。このLessonでは、どのようなものを管理すべきでないのか紹介し、それらを無視するための設定方法について紹介します。

- Gitで管理すべきでないファイル
    
    Gitでバージョン管理すべきではないファイルというものが存在します。例えば、アプリケーションをビルドする際に自動作成されるパッケージファイルやログファイル、ファイルをコピーしてリネームしたバックアップなどの一時ファイルは、Gitで管理すべきではありません。ログファイルはアプリケーションを実行するたびに出力されるものですし、パッケージファイルはビルドすれば作成されるものなので、あえてバージョン管理をする必要はありません。また、バックアップファイルはGitでバージョン管理をしていれば不要になりますよね。他にも、パスワードのようなセキュリティに関する情報が書かれたファイルも、Gitに登録するべきか必ず検討しましょう。
    
    Gitに登録したファイルは、リモートリポジトリを共有しているメンバー全員に公開されてしまいます。「リモートリポジトリを共有しているメンバーに見られてもいい情報なのか」を必ず意識するようにしましょう。
    
    - Gitで管理すべきではないファイル
        - ログファイル
        - パッケージファイル
        - バックアップファイル
        
        など自動生成される一時ファイルは管理不要。
        
        - WindowsのThumbs.db
        - macOSの.DS_Store
        
        OSのファイル管理のためのものなので不要。
        
        - パスワードが書かれたファイル
        
        リモートリポジトリで共有すべきでない情報。
        
    
    ※不要なファイルがあると、リポジトリのサイズが大きくなったり、無駄なコミットやコンフリクトが発生したりと、いろいろな問題が起きます。
    
- Gitで管理しないファイルを設定しよう
    
    ステージングエリアへ登録する時に、毎回Gitで管理したくないファイルを意識するのは大変ですし、ミスが発生する可能性もあります。そういう時のためにGitで管理しないファイルを設定できます。設定は簡単で、.gitignoreファイルというテキストファイルをローカルリポジトリに配置して、そこに無視したいファイル名やディレクトリ名を書くだけです。.gitignoreファイルはローカルリポジトリ配下であればどこに置いてもいいですが、.gitignoreファイルが配置されたディレクトリ配下のパスにしか効果がありません。ローカルリポジトリ内のすべてのディレクトリに設定を反映するには「.git」ディレクトリと同じディレクトリに保存しましょう。
    
    設定してしまえば、git statusコマンドでファイルが表示されることもなく、git addコマンドでディレクトリを指定した時にも、そのファイルは無視されます。
    
    - .gitignoreの配置場所
        - 「ichiyasa」ディレクトリ(カレントディレクトリ)
            - 「.git」ディレクトリ
            - .gitignore
                - .gitignoreの内容→sample.txt
            - Git_MEMO.md
            - sample.txt→.gitignore内にあるのでGitに無視される
        
        ※.gitignoreファイルは、その名のとおり「Gitが無視(ignore)する」設定をします。
        
    - .gitignoreの書き方
        - ファイル名を直接指定する
        - ディレクトリ名を指定する(ディレクトリ全体が対象)
        - *(アスタリスク)を使えば、ファイルの拡張子で指定できる
- .gitignoreファイルを作ってみよう
    
    .gitignoreの効果を体感するために、Gitの管理から外したい「sample.txt」ファイルを作成し、.gitignoreファイルに指定して無視させてみましょう。
    
    1. 「sample.txt」ファイルを作成する
        1. Visual Studio Codeを起動して、「sample.txt」という名前で保存します。「sample.txt」の中身は何も書かなくて構いません。
            1. ファイルタグから「新しいテキストファイル」をクリック→ファイルタグから「名前を付けて保存…」をクリック
            2. Finderが開くので、ファイル名を「sample.txt」という名前に、保存する場所は「Git_MEMO.md」と同じディレクトリにすること。今回の場合は「ichiyasa」という名前のディレクトリ。
    2. .gitignoreファイルを作る前の状態を確認する
        
        ```bash
        $ git status
        
        ichiyasa % git status
        On branch main
        Changes not staged for commit:
          (use "git add <file>..." to update what will be committed)
          (use "git restore <file>..." to discard changes in working directory)
        	modified:   Git_MEMO.md
        
        Untracked files:
          (use "git add <file>..." to include in what will be committed)
        	sample.txt # 「sample.txt」ファイルがUntracked filesに表示されている ファイルを作成しただけでGitの管理下にはファイルが登録されていない状態
        
        no changes added to commit (use "git add" and/or "git commit -a")
        ```
        
    3. .gitignoreファイルを作成する
        1. 次に.gitignoreファイルを作成し、「sample.txt」を指定しましょう。尚、Windowsで.gitignoreファイルのようなファイル名が「.」(ドット)で始まるファイルを作成する場合は、Visual Studio Codeからファイルを作成するようにしてください。それ以外の方法だと面倒な手間が発生することがあります。
            1. ファイルタグから「新しいテキストファイル」をクリック→ファイルタグから「名前を付けて保存…」をクリック
            2. Finderが開くので、ファイル名を「.gitignore」という名前に、保存する場所は「sample.txt」と同じディレクトリにすること。今回の場合は「ichiyasa」という名前のディレクトリ。
    4. .gitignoreファイルを作った後の状態を確認する
        1. .gitignoreに「sample.txt」を指定した前後でgit statusコマンドの実行結果が変わっています。「sample.txt」が表示されなくなり、ファイルはGitから無視されるようになりました。
        
        ```bash
        $ git status
        
        ichiyasa % git status
        On branch main
        Changes not staged for commit:
          (use "git add <file>..." to update what will be committed)
          (use "git restore <file>..." to discard changes in working directory)
        	modified:   Git_MEMO.md
        
        Untracked files:
          (use "git add <file>..." to include in what will be committed)
        	.gitignore # 「sample.txt」ファイルが表示されなくなり、.gitignoreファイルがUntracked filesに表示
        
        no changes added to commit (use "git add" and/or "git commit -a")
        ```
        
    5. .gitignoreファイルをステージングエリアに登録する
        
        ```bash
        $ git add .gitignore
        
        ichiyasa % git add .gitignore
        ```
        
    6. .gitignoreファイルをコミットする
        
        ```bash
        $ git commit -m ".gitignoreファイルを追加する"
        
        ichiyasa % git commit -m ".gitignoreファイルを追加する"
        [main 06b898e] .gitignoreファイルを追加する
         1 file changed, 1 insertion(+)
         create mode 100644 .gitignore # .gitignoreファイルがコミットされた
        ```
        
    
    ※macOSでは「.DS_Store」ファイル、Windowsでは「Thumbs.db」ファイルが、フォルダーに作成されることがあります。これらのファイルはGitで管理する必要がないので、.gitignoreファイルに設定しておきましょう。
    
- **ワンポイント** .gitignoreファイルのテンプレート
    
    さまざまなプログラミング言語やツールのための.gitignoreファイルのテンプレートをGitHub社がオープンソースで公開しています。
    
    .gitignoreファイルの書き方に迷ったら、こちらを参考にしてみましょう。( [https://github.com/github/gitignore](https://github.com/github/gitignore) )
### 用語
- **Gitで管理すべきではないファイル**：アプリケーションをビルドする際に自動作成されるパッケージファイルやログファイル、ファイルをコピーしてリネームしたバックアップなどの一時ファイル。
- **コンクリフト**：複数ブランチで(複数人で)同じファイルの同じ箇所を編集した後に起こる衝突。必要な内容を勝手に上書きしないための機能。
- **.gitignore**：Gitで管理したくないファイルやディレクトリを指定するためのファイル。先頭の「.」は隠しファイルであることを意味します。
- **untracked**：(追跡されていない)ファイルを表す。</details>


<details><summary>Lesson 22 [コミット履歴の確認] コミットの履歴を確認しましょう</summary>

ローカルリポジトリに対して何度かコミットした時やリモートリポジトリから変更を反映した時に、どのような作業をしたのか確認したくなることがあると思います。そのようなときは、コミットの履歴を確認することで過去の作業を振り返ることができます。

- ローカルリポジトリのコミットの履歴を確認しよう
    
    コミット履歴を確認するにはgit logコマンドを使用します。git logコマンドを実行すると、新しい順に、「コミットハッシュ」「誰がコミットしたか」「コミットした日時」「コミットメッセージ」が表示されます。
    
    Chapter 1のコラムで紹介したとおり、「コミットハッシュ」はランダムな英数字で、これを利用することでコミットを特定できます。「誰がコミットをしたか」にはgit configコマンドで設定したユーザー名とメールアドレスが表示されます。
    
- コミット履歴を確認する
    1. 「ichiyasa」ディレクトリのコミット履歴を確認する
        1. git logコマンドで、コミット履歴を確認できます。コミット履歴は大抵の場合、かなり長くなります。git logコマンドの実行結果がウィンドウに入り切らないときは、ウィンドウの一番下に「:」(コロン)が表示された状態になります。このとき、キーボードの上下キーを押すことで、ウィンドウの表示をスクロールできます。表示を止めるときはQキーを押すと、コマンドラインに戻ります。git configコマンドの操作と同じですね(P.63参照)。
        
        ```bash
        $ git log # コミット履歴を確認するコマンド
        
        yoshiwo@Yoshiwos-MacBook-Pro ichiyasa % git log
        commit 06b898e4d511bacaed09c9b70907337724e4f12a (HEAD -> main)
        Author: yoshiwo.may15 <yoshiwo.may15@gmail.com>
        Date:   Tue Aug 2 17:10:57 2022 +0900
        
            .gitignoreファイルを追加する
        
        commit 642aeee52c97f1379bb7e460b78d6235dbb70f8f
        Author: yoshiwo.may15 <yoshiwo.may15@gmail.com>
        Date:   Tue Aug 2 11:39:24 2022 +0900
        
            remove_me.txtファイルを削除する
        
        commit eda820545f889d028fbf36f10aa369abf6f1af49
        Author: yoshiwo.may15 <yoshiwo.may15@gmail.com>
        Date:   Tue Aug 2 11:21:09 2022 +0900
        
            削除対象のファイルを作成
        
        commit 9c379b8acd7ec7c3a801bcac185ee9edc751b2a8
        Author: yoshiwo.may15 <yoshiwo.may15@gmail.com>
        Date:   Sat Jul 30 15:58:36 2022 +0900
        
            ローカルリポジトリの作成とステータスの確認コマンドを記載
        
        commit 2da8208f45243b64a0b65fe7b36aed23f5f21a14
        Author: yoshiwo.may15 <yoshiwo.may15@gmail.com>
        Date:   Fri Jul 29 16:58:16 2022 +0900
        
            Gitの学習メモを作成
            
            Gitのコマンドをメモするための学習メモを作成する
            まずはタイトルだけ記録した。
        ```
        
    2. 差分付きでコミット履歴を確認する
        1. git logコマンドで履歴を確認する際、コミットメッセージだけでなく、もう少し作業内容の情報が欲しい時もあるかと思います。そのような時はgit logコマンドに「-p」オプションをつけることで、git diffコマンドの時に確認したようなファイルの差分を確認できます。
        
        ```bash
        $ git log -p # 前のコミットとの差分入りでコミットログが表示される
        
        yoshiwo@Yoshiwos-MacBook-Pro ichiyasa % git log -p                                  
        commit 06b898e4d511bacaed09c9b70907337724e4f12a (HEAD -> main)
        Author: yoshiwo.may15 <yoshiwo.may15@gmail.com>
        Date:   Tue Aug 2 17:10:57 2022 +0900
        
            .gitignoreファイルを追加する
        
        diff --git a/.gitignore b/.gitignore
        new file mode 100644
        index 0000000..bdbc095
        --- /dev/null
        +++ b/.gitignore
        @@ -0,0 +1 @@
        +sample.txt
        \ No newline at end of file
        
        commit 642aeee52c97f1379bb7e460b78d6235dbb70f8f
        Author: yoshiwo.may15 <yoshiwo.may15@gmail.com>
        Date:   Tue Aug 2 11:39:24 2022 +0900
        
            remove_me.txtファイルを削除する
        
        diff --git a/remove_me.txt b/remove_me.txt
        deleted file mode 100644
        index e69de29..0000000
        
        commit eda820545f889d028fbf36f10aa369abf6f1af49
        Author: yoshiwo.may15 <yoshiwo.may15@gmail.com>
        Date:   Tue Aug 2 11:21:09 2022 +0900
        
            削除対象のファイルを作成
        
        diff --git a/remove_me.txt b/remove_me.txt
        new file mode 100644
        index 0000000..e69de29
        
        commit 9c379b8acd7ec7c3a801bcac185ee9edc751b2a8
        Author: yoshiwo.may15 <yoshiwo.may15@gmail.com>
        Date:   Sat Jul 30 15:58:36 2022 +0900
        
            ローカルリポジトリの作成とステータスの確認コマンドを記載
        
        diff --git a/Git_MEMO.md b/Git_MEMO.md # 前のコミットとの差分入りでコミットログが表示されている箇所
        index 2a3fcae..ea7bf3a 100644
        --- a/Git_MEMO.md
        +++ b/Git_MEMO.md
        @@ -1,2 +1,7 @@
         # Git学習メモ
        -## Gitコマンド
        \ No newline at end of file
        +## Gitコマンド
        +
        +- ローカルリポジトリを作る
        +      - git init
        +- ファイルの状態を確認
        +      - git status
        \ No newline at end of file
        
        commit 2da8208f45243b64a0b65fe7b36aed23f5f21a14
        Author: yoshiwo.may15 <yoshiwo.may15@gmail.com>
        Date:   Fri Jul 29 16:58:16 2022 +0900
        
            Gitの学習メモを作成
            
            Gitのコマンドをメモするための学習メモを作成する
            まずはタイトルだけ記録した。
        
        diff --git a/Git_MEMO.md b/Git_MEMO.md
        new file mode 100644
        index 0000000..2a3fcae
        --- /dev/null
        +++ b/Git_MEMO.md
        @@ -0,0 +1,2 @@
        +# Git学習メモ
        +## Gitコマンド
        \ No newline at end of file
        ```
        
- **ワンポイント** コミット履歴を視覚的に確認する
    
    コミットの数が増えてくると、コマンドラインからでは特定のコミットを見つけるのが難しくなってしまいます。GUIクライアントを使えば、コミット履歴を視覚的にわかりやすく確認できます。
### 用語
- **git logコマンド**：コミット履歴を確認する。
- **git log -p**：前のコミットとの差分入りで、コミットログが表示される。</details>

# Chapter 4 GitHubのリポジトリをパソコンに取得しよう

今までの章では個人作業がメインでしたが、ここからは複数人での共同作業について手を動かしながら学んでいきます。

Gitのみならず、GitHubの使い方についても触れていくので、気持ちを切り替えて臨みましょう。

<details><summary>Lesson 23 [Git Hubの登録] GitHubを使う準備をしましょう</summary>

今までの章では個人作業がメインでしたが、ここからは複数人での共同作業について手を動かしながら学んでいきます。Gitのみならず、GitHubの使い方についても触れていくので、気持ちを切り替えて臨みましょう。

- Lesson 23 [Git Hubの登録] GitHubを使う準備をしましょう
    
    これ以降、最終章まで、Gitと並んで本書が大きなテーマとしているGitHubというWebサービスを扱います。このLessonではその準備として、GitHubがどんなものかを理解してください。その後、実際に使っていくため、アカウントの作成を行いましょう。
    
    - GitHubとは何かを知ろう
        
        GitHub( [https://github.com](https://github.com) )は、多くの開発者に親しまれるWebサービスの名称です。Gitのリポジトリを作成してソースコードをホスティングすることができ、インターネットに接続可能な環境であればどこにいても開発作業を行えます。また、複数人での共同作業がしやすいような機能を備えていることも大きな特徴です。こうした特徴は、これ以降のChapterで十分に体感できると思いますので、楽しみにしていてくださいね。リポジトリは「プライベート」という設定(アクセスを許可した特定のユーザーのみが使用できる状態)にしない限り、誰にでも閲覧できる状態(パブリック)でGitHub上で公開されます。個人が趣味で作ったものから世界的な大企業が公開しているものまで、さまざまなリポジトリにアクセスすることができるので、ぜひいろいろと見てみてください。尚、有料プランでないと一部機能に制限がかかりますが、ほとんどの機能は無料で十分使うことができます。
        
        ※GitHubを使えば最小限の手間でリモートリポジトリを用意できます。
        
    - アカウントを作成し、GitHubユーザーになろう
        
        本書では、これ以降皆さんにも手を動かしていただきながらGitHubの活用方法を学習していきます。そのための第一歩として、GitHubのアカウントを作成しましょう。
        
        1. アカウント作成を開始する
            1. GitHub( [https://github.com](https://github.com) )にアクセスし、アカウントの作成を始めます。
                        
        2. アカウントに必要な情報を設定する
            1. 使用したいユーザー名、メールアドレス、パスワードを入力します。これらの情報は、今後GitHubへログインする際に必要となるので、紛失しないようにしましょう。
            - **Point** アカウント登録の注意点
                
                ユーザー名は好きなものを設定できますが、既にGitHubを使っている他のユーザーと同じものを使うことはできません。もし他のユーザーと重複した場合は入力欄の下に「Username XXX is not available.」というメッセージが表示されるので、別の値を入力しましょう。メールアドレスは、Chapter 2でGitの設定を行なった際に指定したものと同じにしてください。また、パスワードは短すぎたり簡単に予測されたりしないような、安全なものを設定しましょう。
                
        3. メールアドレスを確認する
            1. 入力したメールアドレスに、アカウント確認用のパスコードが送られます。パスコードを入力して認証を完了させましょう。
        4. GitHubの用途などの情報を入力する
            1. 皆さん自身のことについていくつか質問されます。このステップは必須ではありません。飛ばしたい場合はページ下部の[skip personalization]とクリックすると、入力を行わずにアカウントの作成を続行します。
        5. プランを選択し、アカウント作成を完了する
            1. 無料か有料か、プランを決めます。有料にしたい明確な理由がない限り、無料プランを選択しておきましょう。後で必要になってから有料プランに変更することもできます。
            
            ※アカウント作成直後はログインした状態となっています。ログアウトした場合は、GitHubのページ右上に表示されている[Sign in]をクリックし、ユーザー名とパスワードを入力して再ログインしましょう。</details>


<details><summary>Lesson 24 [Git Hubの利用準備] GitHubに公開鍵を設定しましょう</summary>

GitHubに対して操作を行う際、認証が必要になることがあります。このLessonでは、SSHというプロトコルを用いて認証するための設定を行います。慣れない操作もあるかもしれませんが、間違えないよう注意しましょう。

- Gitを使ってGitHubと認証する方法は2つある
    
    手元のパソコンとGitHubとで通信してデータをやり取りするには、認証という手続きが必要となります。現在、GitHubで使用できる認証方式は2つあり、1つは、HTTPSというプロトコルとパーソナルアクセストークン(P.128)を用いたユーザー認証です。もう1つはSSHというプロトコルと公開鍵を用いたサーバー認証です。本書ではこちらを採用します。いずれの方法も最初にコマンドラインやブラウザ上での設定が必要です。SSHを使う場合、最初の設定以降はコマンドライン上で認証のためにユーザー名やパーソナルアクセストークンなどを入力する必要がなく、GitHubに接続する際の手順が軽減できます。
    
    - 通信プロトコルと認証
        
        
        | 通信プロトコル | 認証方法 |
        | --- | --- |
        | SSH | 公開鍵 |
        | HTTPS | ユーザー名とパスワード |
    - 公開鍵による認証方式
        1. ペアの秘密鍵と公開鍵を作成
        2. 公開鍵をGitHubに登録
        3. 鍵を用いて暗号化通信を行う
        
        ※「SSH」や「公開鍵」の仕組みが分からなくても使うことはできますが、仕組みも理解できた方が望ましいので、時間のある時に調べてみてくださいね。
        
- SSH Keyを作成する
    1. SSH Keyを作成する ※事前にGitHubにログインしておくこと。
        1. 以下のコマンドを実行して、鍵(SSH Key)を作成します。”ichiyasa-g-2@example.com”の部分は自分のメールアドレスに置き換えてください。
        
        ```bash
        $ ssh-keygen -t ed25519 -C "emailaddress"
        
        ichiyasa % ssh-keygen -t ed25519 -C "emailaddress"
        Generating public/private ed25519 key pair.
        Enter file in which to save the key (/Users/yoshiwo/.ssh/id_ed25519):
        ```
        
    2. 鍵の保存場所を確認する
        1. 「Enter file in which to save tha key」と表示されたら、returnキーを押してください。この時に表示される絶対パスは、生成した鍵の保存先です。
        
        ```bash
        ichiyasa % ssh-keygen -t ed25519 -C "emailaddress"
        Generating public/private ed25519 key pair.
        Enter file in which to save the key (/Users/yoshiwo/.ssh/id_ed25519): #ここでreturnキーを押す
        
        ichiyasa % ssh-keygen -t ed25519 -C "emailaddress"
        Generating public/private ed25519 key pair.
        Enter file in which to save the key (/Users/yoshiwo/.ssh/id_ed25519): 
        Enter passphrase (empty for no passphrase):
        ```
        
    3. パスフレーズを入力する
        1. 続いて「Enter passphrase」表示されるので、パスフレーズ(パスワードのことだと思ってください。SSH Keyの管理に必要です)を入力します。GitHubのパスワードとは別の、今生成するSSH Key専用のパスフレーズを設定してください。尚、確認用に2度入力が必要です。
        
        ```bash
        ichiyasa % ssh-keygen -t ed25519 -C "emailaddress"
        Generating public/private ed25519 key pair.
        Enter file in which to save the key (/Users/yoshiwo/.ssh/id_ed25519): 
        Enter passphrase (empty for no passphrase): # ここでパスフレーズを2回入力する
        
        ichiyasa % ssh-keygen -t ed25519 -C "yosiwo.may15@gmail.com"
        Generating public/private ed25519 key pair.
        Enter file in which to save the key (/Users/yoshiwo/.ssh/id_ed25519): 
        Enter passphrase (empty for no passphrase): 
        Enter same passphrase again:　# 1回目入力後の表示、パスフレーズは入力しても画面に表示されない
        
        ichiyasa % ssh-keygen -t ed25519 -C "yosiwo.may15@gmail.com"
        Generating public/private ed25519 key pair.
        Enter file in which to save the key (/Users/yoshiwo/.ssh/id_ed25519): 
        Enter passphrase (empty for no passphrase): 
        Enter same passphrase again: # 2回目入力後の表示が以下の文字列になる
        Your identification has been saved in /Users/yoshiwo/.ssh/id_ed25519. # あなたのIDは/Users/yoshiwo/.ssh/id_ed25519に保存されています。
        Your public key has been saved in /Users/yoshiwo/.ssh/id_ed25519.pub. # 公開鍵は /Users/yoshiwo/.ssh/id_ed25519.pub に保存されています。
        The key fingerprint is: # 鍵のフィンガープリントは次のとおりです:
        SHA256:AXOJQ+NPNV7t/PGHWihrKX8DE2IhdpSLERAuegDQVOo yosiwo.may15@gmail.com
        The key's randomart image is:
        +--[ED25519 256]--+
        |+o..++*+ooo ..   |
        |. .o .*==o o  .  |
        |. o ...*oo.  o   |
        | + .  .o+..   o. |
        |. E    .S. . . oo|
        | .        + . o +|
        |           * o  .|
        |        . + +    |
        |         +.. .   |
        +----[SHA256]-----+
        ```
        
- SSH KeyをGitHubに登録しよう
    1. 公開鍵をクリップボードにコピーする
        1. 生成した公開鍵をGitHubの設定画面に登録するために、次のコマンドを実行してクリップボード(command + C と同じアクションを行う)にコピーします。WindowsとmacOSでコマンドが異なります。
        - macOSの場合
            
            ```bash
            $ pbcopy < /Users/ichiyasa/.ssh/id_ed25519.pub
            
            ichiyasa % pbcopy < /Users/yoshiwo/.ssh/id_ed25519.pub # 入力してreturnキーを押す
            # Usersの後ろはyoshiwo
            ```
            
    2. GitHubの設定画面を表示する
        1. GitHubのSettingsを開きます。左側のメニューより[SSH and GPG Keys]を選択した後、[New SSH Key]をクリックします。
            1. アイコンをクリック
            2. [Settings]を選択
            3. 左側の列にある[SSH and GPG keys]を選択
            4. SSH keysの行にある、[New SSH key]をクリック
    3. 公開鍵を貼り付ける
        1. [Title]を入力し、[Key]のフィールドに公開鍵をペーストします。[Title]の内容は自由ですが、あとで見た時にどのパソコンで発行したキーなのかわかる情報を入力しておくのがオススメです。入力が完了したら、[Add SSH key]をクリックしましょう。
            1. [Title]にタイトルを入力
            2. 公開鍵をペースト $ pbcopy < /Users/ichiyasa/.ssh/id_ed25519.pubでコピーした内容をそのままペーストすればよい。※コピー後はペーストするまで他のものをコピーしないこと。
            3. [Add SSH key]をクリック
- 正しく設定できたことを確認しよう
    1. 確認用のコマンドを入力する
        1. 鍵の設定がうまくいったことを確認するため、次のコマンドを実行してください。「Are you sure you want to continue connecting (yes/no)?」と問われたら「yes」と入力します。
        
        ```bash
        $ ssh -T git@github.com
        
        ichiyasa % ssh -T git@github.com
        The authenticity of host 'github.com (20.27.177.113)' can't be established.
        ECDSA key fingerprint is SHA256:p2QAMXNIC1TJYWeIOttrVc98/R1BUFWu3/LiyKgUfQM.
        Are you sure you want to continue connecting (yes/no/[fingerprint])? yes # 「yes」と入力してreturnを押す
        ```
        
    2. パスフレーズを入力する
        1. 続いて先程設定したパスフレーズを入力してください。「Hi ユーザー名! You’ve successfully authenticated」と表示されたら設定は成功です。
        
        ```bash
        ichiyasa % ssh -T git@github.com
        The authenticity of host 'github.com (20.27.177.113)' can't be established.
        ECDSA key fingerprint is SHA256:p2QAMXNIC1TJYWeIOttrVc98/R1BUFWu3/LiyKgUfQM.
        Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
        Warning: Permanently added 'github.com,20.27.177.113' (ECDSA) to the list of known hosts.
        Enter passphrase for key '/Users/yoshiwo/.ssh/id_ed25519': # ここでパスフレーズを入力してreturnを押す
        
        Enter passphrase for key '/Users/yoshiwo/.ssh/id_ed25519': 
        Hi YSWEngineer! You've successfully authenticated, but GitHub does not provide shell access.
        # 設定は成功した
        ```
        
        ※「Permission denied」と表示されたら失敗です。手順をやり直してください。また、これ以降ターミナルでの操作中にパスフレーズを聞かれたら、この値を入力しましょう。GitHubのパスワードと混同しやすいですが、ターミナルでパスワードを入力する機会はありません。必ずパスフレーズを使うと覚えておきましょう。
        
- **ワンポイント** Settingsメニューでさまざまな設定ができる
    
    今回は公開鍵の設定を紹介しましたが、Settingsメニューでできることは他にもあります。例えば、プロフィールの設定をして自分がどんな人物なのか伝えたり、メールで通知を受ける内容をカスタマイズしたり、いろいろと自分好みの設定が可能です。また、2段階認証を有効化するといった、安全にサービスを使うための機能も備わっています。
### 用語
- **GitHubで使用できる認証方法2つ**
    - **HTTPS**：プロトコルとパーソナルアクセストークンを用いたユーザー認証。
    - **SSH**：プロトコルと公開鍵を用いたサーバー認証。※本書ではこちらを採用。
        - SSHを使用する場合、最初の設定以降はコマンドライン上で認証のためにユーザー名やパーソナルアクセストークンなどを入力する必要がなく、GitHubに接続する際の手順が軽減できる。
- **passphrase**：パスフレーズ(パスワードのこと)。
    - SSH KeyのパスフレーズはGitHubのパスワードとは別物であることに注意。ターミナルでGitHubのパスワードを入力する機会はありません。必ずパスフレーズを使うと覚えておくこと。</details>


<details><summary>Lesson 25 [リモートリポジトリのフォーク] サンプルプロジェクトを自分のアカウントの管理下にコピーしましょう</summary>

実際に手を動かしながら複数人での共同開発やGitHubの使い方について理解していただくため、サンプルプロジェクトとそれを使ったシナリオを用意しました。先ずは、サンプルプロジェクトを皆さんのGitHubアカウントの管理下に置いてみましょう。

- Chapter 4~7で扱うシナリオと登場人物を知ろう
    
    ここからは皆さんには「イチヤサさん」という、シナリオの主人公役となってもらいます。
    
    イチヤサさんは、外部から講師を招いて初心者向けのGit勉強会を開催することにしました。イベントを盛り上げるため参加者を多く募ろうと、案内用にイベント概要を記載したWebページを作ることが決まっています。ページの大枠はサークル内のシガさん作ってくれたので、完成に向けてメンバー数名で協力して作業することになりました。勿論、Webページを構成するHTMLやCSSなどのファイルはGitで管理し、共同作業にはGitHubを用います。
    
- フォーク機能でGitHub上のリポジトリを複製する
    
    これからシナリオを進めるにあたって、Webページを構成するHTMLやCSSなどを、Gitで管理された状態で取得する必要がありますね。本書では、必要なファイルの用意やリポジトリの作成でなるべく躓かないよう、サンプル用のリモートリポジトリをあらかじめ用意しておきました(これ以降、「サンプルプロジェクト」と呼びます)。皆さんにはそれを複製して学習を進めてもらいます。GitHubは、リポジトリを複製する「フォーク」という機能を提供しています。フォークを活用することで、複製元となるオリジナルのリポジトリに影響を与えることなく、ファイルに変更を加えることができます。一般的なのは、共同開発をしたいリポジトリをフォークし、フォークした先で変更を加えたあと、最終的にフォーク元のオリジナルへ、その変更を反映させるという使い方です。但し今回は、フォークした先のみで作業を行うので、一度フォークしたらオリジナルのことは忘れてしまって大丈夫です。
    
- **ワンポイント** IDとパスワードによる認証は廃止された
    
    HTTPSを使う際、以前はGitHubのユーザー名とパスワードを入力して認証することもできました。しかし、セキュリティ向上を主な理由としてこの方法は2021年8月に廃止されています。代わりとなるのがパーソナルアクセストークン(PAT)ですが、設定にGitHubの基本的な知識が必要となること、筆者の経験上SSHが多く使われていることなどから本書ではSSHを採用しました。PATの設定方法も公式ドキュメントがあるので、興味のある方は調べてみてください。
    
- ワンポイント 実際に手を動かしてシナリオを進めよう
    
    これ以降、登場人物となったつもりで操作しながら読み進めていただくことをオススメします。シナリオの都合上、シガさんの操作は別のアカウントが必要となる箇所があるので以下のいずれかの方法をとってください。但し、1つ目を選んだ場合もChapter 7のみ1人2役やっていただいた方が理解が進むはずです。GitHubアカウントは1つで大丈夫です。
    
    - シガさんの操作は本書で読んで確認するのみとし、実行しない(メインの操作しか体験できませんが、素早く読み進められ手順もシンプルです)
    - 別のGitHubアカウントを作成し、全員分の操作を1人で行う(アカウントを切り替えながらの操作が煩雑で時間がかかりますが、紹介する全パートを体験できます)
    - 友達や仕事仲間などと一緒にそれぞれの役をやってみる(1人で学習する場合は不可能ですが、最も現実に近い形を実現できます)

※ここからはチーム作業を想定した内容となるので、どうしても1人ではやりづらい部分も出てきます。皆さんの目的や学びやすさに合った方法を見つけてください。ちなみに、1人で2アカウントを使う場合はブラウザの「シークレットウィンドウ」を活用するのもオススメです。

- サンプルプロジェクトをフォークしよう
    1. 複製元のリポジトリでフォークを開始する
        1. 理解さえしてしまえば、フォークは簡単な操作で完了します。①複製元のリポジトリを表示した状態で、②右上にある[Fork]をクリックしてください。ちなみに、ボタンの隣にある数値は、フォークにより作成されたリポジトリの数を表しています。
        - サンプル用のリモートリポジトリのURL
            
            [https://github.com/yasagit-2/ichiyasaGitSample](https://github.com/yasagit-2/ichiyasaGitSample)
            
        
        ![ichiyasaGitSample.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4ecffa00-637a-40d5-b480-1d804ccffa39/ichiyasaGitSample.png)
        
        ※↑ここでアカウントを選択する画面が表示された場合は、自分のアカウントを選択してください。
        
        ![Create a new fork.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/db3941d2-0d8a-426a-90d7-ad2eb1c6fcb5/Create_a_new_fork.png)
        
    2. フォークが完了した
        1. フォークが完了すると、フォークにより作成されたリポジトリの画面が開かれた状態となります。内容が同じなので一見同じものに見えますが、自分のアカウントのページに変わっています。
        
        ![forked.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a5cd2053-6a80-4e57-b06e-e1f7df5638b4/forked.png)
        
        ※フォークで作成したリモートリポジトリは自分の管理下に置かれるため、他への影響を気にせず自由に操作できます。
        
- **ワンポイント** Codeタブでどんなリポジトリか見てみよう
    
    リポジトリの画面を開くと、ページ上部にあるいくつかのタブのうち[Code]が選択された状態になります。ここでは、リポジトリの簡単な説明、管理しているファイルのフォルダー構成、URLなどを確認することができます。また、途中にカラフルなバーがあるのにお気付きでしょうか。ここをクリックすると、リポジトリ内のファイルがどんな言語で書かれているかの割合が見られるようになっています。[Code]ダブは、いわばリポジトリのプロフィールが見られるようなページですね。
### 用語
- **リポジトリ**：コミット(記録)を貯めていく場所のこと。
- **リモートリポジトリ**：インターネット上に存在するリポジトリのこと。複数人で共有するものとして、サーバー上に配備するのが一般的。
- **フォーク**：リポジトリを複製するGitHubの機能。複製元となるオリジナルのリポジトリに影響を与えることなく、ファイルに変更を加えることができる。
- (GitHub内において)**フォークの右側の数字**：フォークにより作成されたリポジトリの数を指す。
- GitHubの[**Code**]：リポジトリのプロフィールが見られるようなページ。</details>


<details><summary>Lesson 26 [リモートリポジトリのクローン] イベント案内ページをパソコンに取得しましょう</summary>

シガさんが用意したリポジトリを自分のパソコンで使えるようにしましょう。手順は簡単で、たった1コマンド、リモートリポジトリをローカルリポジトリとしてコピーする操作を行うだけです。この操作を「クローン」といいます。

- シガさんが作成したページをローカルリポジトリに取得する
    
    シガさんはWebページのソースコードをGitHubに公開してくれました。1つ前のLessonでそれを複製して、イチヤサさん(あなた)のリポジトリを作成しました。今度はそれを自分のローカルリポジトリとして取得し、開発の準備を整えます。この操作はgit cloneコマンドで行います。
    
    - クローンでリモートリポジトリを作成する
        1. シガさんの yasagit-2アカウントのichiyasaGitSampleリポジトリ (リモートリポジトリ)をフォークする。
        2. フォークでシガさんのリポジトリを複製したリポジトリにクローンを行う。
        3. (クローンを行った結果)ローカルリポジトリを作成。
    - git cloneコマンドの使い方
        
        ```bash
        $ git clone git@github.com:ichiyasa-g-2/ichiyasaGitSample.git
        # git clone = git cloneコマンド
        # git@github.com:ichiyasa-g-2/ichiyasaGitSample.git = GitHubからコピーするクローン用URL
        ```
        
- リモートリポジトリをクローンしよう
    1. リモートリポジトリのURLを取得する
        1. 初めに、リモートリポジトリを特定するためのURLをGitHubで取得しましょう。①フォークしたリポジトリのページで[Code]をクリックし、②[SSH]のタブを選択してから③クリップボードのコピーしましょう。
                
    2. クローンを実行する
        1. git cloneコマンドでクローンを実行しましょう。パラメーターにリモートリポジトリのURLを指定して実行すると、そのコピーがローカルリポジトリとして作成されます。Git Bashで貼り付けを行うには、画面上を右クリックして表示されるメニューから[Paste]を選択するか、shift + Insert キーを押します。
        
        ```bash
        # ①git cloneと入力 ②スペースを入れた後ろにSSHタブで表示されたURLを貼り付ける
        $ git clone git@github.com:YSWEngineer/ichiyasaGitSample.git
        
        ichiyasa % git clone git@github.com:YSWEngineer/ichiyasaGitSample.git
        Cloning into 'ichiyasaGitSample'...
        Enter passphrase for key '/Users/yoshiwo/.ssh/id_ed25519': 
        remote: Enumerating objects: 26, done.
        remote: Total 26 (delta 0), reused 0 (delta 0), pack-reused 26
        Receiving objects: 100% (26/26), 1.36 MiB | 1.53 MiB/s, done.
        # クローンの実行によりリポジトリがコピーされ、パソコンでファイルを確認できるようになる
        ```
        
        ※Chapter 3では、git initコマンドを使ってリポジトリを作成する方法を説明しました。ここで説明するgit cloneコマンドはもう1つの作成方法です。
        
    3. クローンされたリポジトリのディレクトリに移動する
        1. ホームディレクトリの直下でgit cloneコマンドを実行したため、その中に「ichiyasaGitSample」ディレクトリが作られているはずです。そこがローカルリポジトリなのでcdコマンドでディレクトリ内に移動しましょう。
        
        ```bash
        $ cd ichiyasaGitSample/
        
        ichiyasa % cd ichiyasaGitSample/
        ichiyasaGitSample % # 作成されたディレクトリに移動できた
        ```
        
- リモートリポジトリの設定を確認しよう
    
    git remoteコマンドを使うと、リモートリポジトリの設定を確認したり変更したりすることができます。ここでは、先程クローンしたリポジトリが設定されていることを確認してみましょう。URL情報を確認できる-vオプションをつけて実行すると、「origin」という文字の後に先程指定したURLが2回表示されるはずです。
    
    - git remoteコマンド
        
        ```bash
        $ git remote -v # URL情報を確認できる
        
        ichiyasaGitSample % git remote -v
        origin	git@github.com:YSWEngineer/ichiyasaGitSample.git (fetch)
        origin	git@github.com:YSWEngineer/ichiyasaGitSample.git (push)
        ```
        
- originはリモートリポジトリを表している
    
    git remoteコマンドの実行結果を見ると、「origin」という文字が表示されています。これはクローン元のリモートリポジトリを表す名前です。実はGitでは、1つのローカルリポジトリに対してリモートリポジトリを複数設定できるので、それぞれを識別するために名前が必要です。クローンすると、クローン元のリポジトリにはGitが初期値としてoriginという名前を付けます。この名前は後から変更することも可能ですが、慣習的にoriginのまま使います。今後もコマンドのパラメーターとしてoriginを指定する場面が多々ありますが、どのリモートリポジトリに対して操作するのかを明確にするためだと覚えておきましょう。
    
    ※ちょっとややこしい話ですが、今回はリモートリポジトリが1つだけなので、とりあえず「originという名前がリモートリポジトリを表す」と覚えておけば大丈夫です。
    
- **ワンポイント** GitHubがコマンドで操作できるようになった
    
    本書ではGitHubの操作をブラウザ上で行っていますが、2020年9月に正式リリースされた「GitHub CLI」を使うとコマンドでも扱うことができます(CLIはコマンドラインインターフェースの略)。GitHub上のリポジトリや、後の章で紹介するプルリクエストやイシューなどを管理できるので、ターミナルとブラウザを行き来する頻度を減らせます。
    
    クローンをする際に[HTTPS],[SSH]の他に[GitHub CLI]のタブがあったのにお気付きでしょうか。ここでGitHub CLIをローカルで実行するためのコマンドをコピーできます。
    
    但し、あくまでGitHubを使うためのツールであり、これまで学んできたようなGitの操作ができるわけではないので混同に注意しましょう。
    
- **ワンポイント** GitHubでリポジトリを新規作成する方法
    
    フォークを利用してリポジトリを作成する方法を説明しましたが、新規でリポジトリを作成する方法も知っておきましょう。リポジトリの名前や公開/非公開設定など、最低限の入力だけ済ませればすぐに作ることができます。
    
    - リポジトリ作成画面を利用して新規リポジトリを作成
        1. 右上の[+]メニューから[New repository]をクリック            
        2. リポジトリ名や公開レベル(パブリックかプライベートか)などを入力
        3. [Create repository]をクリック            
        
        ※以前はプライベート(非公開)リポジトリの作成が有料でしたが、2019年より無料になりました。
### 用語
- **git cloneコマンド**：リモートリポジトリをローカルリポジトリとしてコピーする。
- **Git Bash**：Windowsでコマンドを実行するためのツール。
- **git init**：ローカルリポジトリを作成する。
- **cdコマンド**：cdコマンドの後ろにディレクトリパスを付けることで、他のディレクトリに移動できる。
- **git remoteコマンド**：リモートリポジトリの設定を確認したり変更したりすることができる。
- **git remote -vオプション**：URL情報を確認できる。</details>


<details><summary>Lesson 27 [開発環境の準備] Webページの編集作業をするための準備をしましょう</summary>

最後に、クローンで取得したサンプルプロジェクトを編集したり、Webページとして表示したりする手順を説明します。ここまで済ませれば本格的な共同開発へ移ることができるので、楽しみにしていてくださいね。

- サンプルプロジェクトをVisual Studio Codeで編集しよう
    
    Markdowwnファイルを扱っていたこれまでのChapterとは異なり、Chapter 5以降は主な編集対象がHTMLファイルとなります。しかし、Visual Studio Codeで作業をしていくことに変わりはありません。Visual Studio Codeはマウス操作で起動してもいいのですが、コマンドラインから起動して、Gitの操作からスムーズに切り替える方法を紹介します。本書の手順に沿ってVisual Studio Codeをインストールしていれば、WindowsでもmacOSでもcodeコマンドで起動できます。
    
    - codeコマンドの使い方
        
        ```bash
        $ code /c/Users/ichiyasa/ichiyasaGitSample
        # code = codeコマンド
        # /c/Users/ichiyasa/ichiyasaGitSample = Visual Studio Codeの作業フォルダーにするディレクトリパス
        ```
        
- コマンドラインからVisual Studio Codeを起動する
    1. codeコマンドを入力する
        1. codeコマンドの後にディレクトリパスを書きます。すでにローカルリポジトリのディレクトリを表示している場合は、カレントディレクトリを表す相対パスの「.」(ドット)を指定するだけで済みます。
            
            ```bash
            $ code .
            ```
            
    2. Visual Studio Codeでファイルを開く
        1. ディレクトリを指定して起動すると、左側のエクスプローラーにそのディレクトリ内のファイルやディレクトリが表示されます。ファイル名をクリックして数早く開くことができます。
            
- ブラウザーでWebページの表示を確認しよう
    
    Visual Studio CodeでHTMLを見るだけでなく、ブラウザーでWebページとしての見た目を確認しながら進めるとイメージしやすいはずです。先程クローンで取得したファイルのうち、index.thmlをブラウザーで開いてみてください。Windowsならエクスプローラー、macOSならFinderでクローンしたディレクトリ(フォルダー)を開き、ファイルをダブルクリックしてください。--Finderからクローンしたディレクトリを開いて確認済み。
    
    ※HTMLについての知識はなくてもLessonは進められるので、心配無用です。本書の真似をしながら進めてくださいね。
    
- **ワンポイント** コマンドラインからエクスプローラーやFinderを起動する
    
    エクスプローラーやFinderも、パスを指定してコマンドを実行するとコマンドラインから起動できます。何度もクリックしてディレクトリを移動する必要がなくなるのでオススメです。これも絶対パス/相対パスのいずれでも指定が可能ですが、ここでは絶対パスを使っていきます。
    
    - macOSの場合
    
    ```bash
    $ open /Users/ichiyasa/ichiyasaGitSample
    ```

### 用語
codeコマンド：ターミナルからVisual Studio Codeを起動できる。</details>

# Chapter 5 ブランチを使ってファイルを更新しよう

GitHubを用いたメジャーな作業フローで、イベントページの更新作業を行います。フローを実践する中で、ブランチという重要な機能についても学びます。しっかり手を動かして使いこなせるようになってくださいね。

<details><summary>Lesson 28 [ブランチの基本] ブランチとは何かを理解しましょう</summary>

ブランチは、同じリポジトリ内で並行して異なる作業をする際に役立つ重要な機能です。Gitを用いた開発を進める上では使いこなせることが必須と言えるでしょう。ここでは、まず基本を抑えるために、ブランチそのものについて解説します。

- ブランチで並行作業がしやすくなる
    
    ブランチは簡単にいうと、Gitで記録する履歴を枝分かれさせるための機能です。これまでは、コミットが一直線に並ぶようなイメージのみ紹介してきましたが、それだけでは不便なことも多々あります。
    
    例えば、同時に複数の異なる作業をしたい場合、内容ごとに別々に管理ができた方が望ましいです。また、アプリケーション開発をしていて、本番環境とテスト環境それぞれで異なるバージョンを動かしたいときも、ブランチを活用することでバージョンの切り替えが容易にできます。
    
    ※ブランチはGitの大きな強みです。使いこなせると、できることの幅がグッと広がりますよ。
    
- ブランチを統合することを「マージ」と呼ぶ
    
    枝分かれさせたブランチは、任意のタイミングで統合できます。この作業を「マージ」と呼びます。マージのタイミングや方法はさまざまですが、このあとの実践パートで紹介します。
    
- これまで使っていたのはmasterブランチ
    
    実は、これまでもすでにブランチを使っていました。Gitのリポジトリを作成すると自動で作られる、masterという名のブランチです。これは主となるバージョン(安定バージョン、最新バージョンなど)を管理するのに用います。レッスンの初めで紹介したように枝分かれした他のブランチで作業をしても、多くの場合、最終的にはmasterブランチにマージを行います。尚、このブランチに別の名前を付けることもできますが、慣習的にmasterまたはmainにすることがほとんどです。
    
- **ワンポイント** 作業人数に関係なく「作業の意味」ごとにブランチを作る
    
    masterは主となるブランチなので、安易に誤った内容を含めるわけにはいきません。そのため、作業用のブランチを作り、変更内容の確認や検証が済んだらmasterブランチにマージする、というフローが一般的です。本書では、GitHubが推奨しており、採用実績も多い「GitHubフロー」を用います。GitHubフローについてはこのChapter 5の最後で改めて解説します。
    
- **ワンポイント** ブランチ名をmasterからmainへ切り替える流れがある
    
    2020年に人権問題を背景とし、master/slaveなどいくつかのIT用語の使用を避けようという動きが起こりました。Gitの世界でもそれまで一般的だったmasterに代わってmainという名のブランチが浸透しつつあります。
    
    執筆時点で、GitHubでは最初に作られるブランチがmainとなっていますが、Gitとちぐはぐですよね。本書では、入門で躓かないよう一貫した説明をするため、そしてmasterのまま運用が続いているリポジトリも多いことから、masterブランチを使った説明を続けます。
### 用語
- **ブランチ**：Gitで記録する履歴を枝分かれさせるための機能。複数の作業を並行して進めるときに使用する。ブランチはマージ(統合)できる。
- **マージ**：枝分かれさせたブランチを統合すること。
    - マージはローカルリポジトリでGitコマンドにより実行することもできるし、GitHubを使ってリモートリポジトリ上でも行うことができる。</details>


<details><summary>Lesson 29 [ブランチを用いた実践1] 専用のブランチでイベント会場の情報を更新しましょう</summary>

ブランチを活用し、シガさんが作ったページ上のイベント開催会場を「株式会社〇〇」から「株式会社インプレス」に変更します。使うコマンドは今後も頻繁に使う基本的なものばかりなので、少しずつ覚えましょう。

- ブランチを用いてイベントの会場情報を更新する
    
    Chapter 4でローカルリポジトリに取得したサンプルプロジェクト(初心者向けGit勉強会のイベントページ)を編集しながら進めます。シガさんがページを作成したときには会場が未定だったため、「株式会社〇〇」と記載していましたが、「株式会社インプレス」で決定となりました。イチヤサさんは、イベント会場を更新するためのブランチを作成し、HTMLの編集とコミットを行います。コミットが完了したら、masterブランチにマージするための作業を行います。マージは、ローカルリポジトリでGitコマンドにより実行することもできますが、今回はGitHubを使ってリモートリポジトリ上で行います。それが完了すると会場情報の変更を無事プロジェクトに反映できたことになり、作成したブランチは役目を終えます。このような、短期的に使う作業用のブランチを「トピックブランチ」と呼びます。
    
    ※マージするときにGitHubの「プルリクエスト」という機能を利用します。
    
- ブランチを作成するためのGitコマンド
    
    ブランチを操作するためのgit branchコマンドを使うと、ブランチの作成ができます。作成したいブランチの名前を指定して実行します。
    
    - git branchコマンド
        
        ```bash
        $ git branch update-venue
        # git branch = git branchコマンド
        # update-venue = 作成するブランチ名
        ```
        
    
    ※作成、名前の変更、削除など、ブランチに対する操作を行えるのがgit branchコマンドです。
    
- ブランチは切り替えながら使用する
    
    ブランチが複数存在する状況では、「どのブランチに対して操作を行うか」ということを意識しなくてはなりません。操作対象となるブランチを指定するには、git checkoutコマンドを用います。このコマンドを実行すると、それ以降の操作対象が切り替わり、指定したブランチが使われるようになります。例えば、update-venueブランチをチェックアウトした後にコミットをすると、update-venueブランチのみコミットが追加され、それ以外のブランチには追加されません。
    
    - git checkoutコマンド
        
        ```bash
        $ git checkout update-venue
        # git checkout = git checkoutコマンド
        # rpdate-venue = 切り替え先のブランチ名
        ```
        
    
    ※はじめは複数のブランチを使うことに混乱するかもしれませんが、ゆっくりと確認しながら作業して慣れていきましょう。
    
- ブランチを作成して切り替える
    1. ブランチを作成する
        1. git branchコマンドを用い、ブランチを作成します。ここでは、「開催会場を更新する」という作業内容を示す「update-venue」という名前のブランチにします。
        
        ```bash
        $ git branch update-venue
        
        % git branch update-venue
        ```
        
        ※もし打ち間違いなどでブランチ名を誤って作成してしまったら、再度改めて正しいブランチ名でコマンドを実行すれば大丈夫です。誤った名前の不要なブランチは、P.206に記載の手順で削除できます。
        
    2. 使用中のブランチを確認する
        1. ブランチ名の指定なしにgit branchコマンドを実行すると、作成済みのブランチ一覧と現在使用中のブランチを確認できます。先頭にアスタリスク(*)が付いているのが、今使っているブランチです。
        
        ```bash
        $ git branch
        
        % git branch
        * master # *が付いているのが今使っているブランチを意味する masterブランチを使用していることがわかる
          update-venue # 先程作成したupdate-venueブランチ
        ```
        
        ※Git Bashでは、カレントディレクトリと一緒に「(使用中のブランチ名)」が表示されているので、すぐに確認できます。
        
    - **ワンポイント** git checkoutコマンドに代わるコマンド
        
        Chapther 3で紹介したとおり、git checkoutコマンドによるブランチの切り替えはgit switchコマンドでも実行できます。これ以降、必要に応じてgit switchを使う方法も紹介します。
        
    1. ブランチをチェックアウトする
        1. 今はまだmasterブランチを使用していることがわかりました。先程作成したupdate-venueブランチへと切り替えるには、「チェックアウト」という操作が必要です。使いたいブランチ名を指定し、git checkoutコマンドを実行してみましょう。
        
        ```bash
        $ git checkout update-venue # update-venueブランチに切り替える
        
        % git checkout update-venue # git switch update-venueでも同じことができる
        Switched to branch 'update-venue' # update-venueブランチに切り替わった
        ```
        
    2. 使用中のブランチを確認する
        1. 再びgit branchコマンドで確認すると、update-venueブランチに切り替わったことがわかります。
        
        ```bash
        $ git branch
        
        % git branch
          master
        * update-venue # *がupdate-venueブランチに付き、現在使用中のブランチがmasterから切り替わったことがわかる
        ```
        
    - **Point** git statusコマンドで確認する
        
        git statusコマンドでも使用中のブランチを確認できます。コマンドを実行するとOn branchに続いて表示されるのが現在使っているブランチです。
        
        ```bash
        % git status
        On branch update-venue # git statusコマンドで使用中のブランチが表示される
        nothing to commit, working tree clean
        ```
        
- ファイルを編集してコミットする
    1. index.htmlを編集する
        1. codeコマンドでVisual Studio Codeを起動し、index.htmlを開きましょう(P.139参照)。「株式会社〇〇イベントセミナー会場」という箇所を書き換えて保存します。

    2. 状態を確認する
        1. 対象ファイルの状態を確認したのち、コミットしてみましょう。先ずはgit stautsコマンドで状態を確認します。
        
        ```bash
        $ git status
        
        % git status
        On branch update-venue
        Changes not staged for commit:
          (use "git add <file>..." to update what will be committed)
          (use "git restore <file>..." to discard changes in working directory)
        	modified:   index.html # index.htmlが「modhified(変更済み)」になっている
        
        no changes added to commit (use "git add" and/or "git commit -a")
        ```
        
    3. 変更をコミットする
        1. git addコマンドでindex.htmlをステージングエリアに登録し、git commitコマンドでコミットします。素早くコミットできる -mオプションを使いましょう。いずれもChapter 3で学習しました。
        
        ```bash
        # コマンドを1行ずつ入力してreturnキーを押すこと
        $ git add index.html
        $ git commit -m "会場を株式会社インプレスに更新した"
        
        % git add index.html
        % git commit -m "会場を株式会社インプレスに更新した"
        [update-venue 93c44d0] 会場を株式会社インプレスに更新した
         1 file changed, 1 insertion(+), 1 deletion(-)
        ```
        
    4. ブランチに対する操作を確認する
        1. これで、update-venueブランチでの作業は完了です。このあと、このブランチをmasterブランチにマージします。その前に、今使っているブランチをmasterブランチと比較してみましょう。Chapter 3で紹介したgit diffコマンドを用いると、ブランチ同士の比較を行うことも可能です。パラメーターに比較対象のブランチを指定して実行してみましょう。会場変更が反映されていることを確認できるはずです。
        
        ```bash
        $ git diff master
        
        % git diff master # 使用中のブランチとmasterブランチとの差分が表示される
        diff --git a/index.html b/index.html
        index b3405fb..3d80220 100644
        --- a/index.html
        +++ b/index.html
        @@ -55,7 +55,7 @@
                             <article>
                                 <h3>イベント日時・場所</h3>
                                 <p>3月23日 19:00開始</p>
        -                        <p>株式会社〇〇 イベントセミナー会場</p> # マイナス記号と赤色の文字は変更前の行
        +                        <p>株式会社インプレス イベントセミナー会場</p> # プラス記号と緑色の文字は変更後の行
                             </article>
                             <article>
                                 <h3>スピーカー</h3>
        ```

        ※マイナス記号と赤色の文字は変更前の行、プラス記号と緑色の文字は変更後の行を表します。
### 用語
- **マージ**：枝分かれさせたブランチを統合すること。
    - マージはローカルリポジトリでGitコマンドにより実行することもできるし、GitHubを使ってリモートリポジトリ上でも行うことができる。
- **トピックブランチ**：短期用に使う作業用にブランチのことを指す。
- **git branchコマンド**：作成、名前の変更、削除など、ブランチに対する操作を行えるコマンド。
    - **(ブランチ名の指定なしに)git branchコマンドを実行**：作成済みのブランチ一覧と現在使用中のブランチを確認できる。
- **git checkoutコマンド**：操作対象となるブランチを指定するコマンド。このコマンドを実行すると、それ以降の操作対象が切り替わり、指定したブランチが使われるようになる。
    - **git checkout 使いたいブランチ名**：使いたいブランチに切り替わる。
- **git switchコマンド**：ブランチを切り替える。
- **git statusコマンド**：現在の状態を確認する。
- **codeコマンド**：ターミナルからVisual Studio Codeを起動できる。
    - codeコマンドのあとにディレクトリパスを書く。すでにローカルリポジトリのディレクトリを表示している場合は、カレントディレクトリを表す相対パスの「.」(ドット)を指定するだけで済む。
- **git addコマンド**：ステージングエリアにファイルを登録する。
    - **ステージングエリア**：コミットするファイルを登録する場所。
- **git commitコマンド**：コミットを作成する(ファイルはステージングエリアからGitディレクトリに移動する(コミット(記録)される))。
    - **git commit -m**：コマンドラインから直接コミットメッセージを指定できる。この時、コミットメッセージは「"」ダブルクォーテーションで囲むこと。
- **git diff**：各エリアの差分を確認する。
- **git diff 比較対象のブランチ名**：ブランチ同士の比較を行うことも可能。</details>


<details><summary>Lesson 30 [ブランチを用いた実践2] プルリクエストを作成しましょう</summary>

作成したブランチをmasterブランチへマージするための準備として、プルリクエストを作成します。ここからはGitHubを使うことも増えてくるので、ターミナルとブラウザーを行ったり来たり忙しくなりますが、チーム開発を想像しながら進めましょう。

- プルリクエストで変更をチームのみんなに知らせる
    
プルリクエスト(pull request)は、GitHubが提供している機能です。「リクエスト」という名からもわかるように、作成したブランチの取り込みを依頼する際に用います。プルリクエストを作成すると、自分がプロジェクトに対し加えた変更を他の開発者に知らせ、その内容について議論できるようになります。尚、プルリクエストを使った議論は、変更を加えた人以外が内容をチェックするという意味で一般的に「レビュー」と呼ばれます。レビューの結果、プロジェクトに取り込む判断がされたブランチはマージすることができますが、修正が必要な場合や、マージをしない判断が下される場合もあります。このシナリオでは、イチヤサさんがシガさんにレビューを依頼するものとします。また、レビューする側を「レビュアー」、される側を「レビュイー」と呼びます。
    
- 「プッシュ」で変更をリモートリポジトリに反映する
    
    プルリクエストを用いたレビューやマージはリモートリポジトリの内容をもとに行うため、ローカルリポジトリからコミットを反映させる必要があります。「プッシュ」という操作を行うと、リモートリポジトリにも同じ内容のブランチが作成されます。その際、特に指定をしなければブランチ名もそのまま同じものが引き継がれますし、別名を付けることも可能です。ただし1つのリポジトリには同じ名前のブランチを2つ以上作成できないので覚えておきましょう。
    
    プッシュはgit pushというコマンドを使います。次のように実行すると、指定したリモートリポジトリ上に、指定したブランチと同じ名前、同じ内容のブランチが作成されます。
    
    - git pushコマンド
        
        ```bash
        $ git push origin update-venue
        # git push = git pushコマンド
        # origin = プッシュ先のリモートリポジトリの名前
        # update-venue = プッシュするブランチ名
        ```
        
- プルリクエストを作成しよう
    1. ブランチをプッシュする
        1. プルリクエストを作成するには、リモートリポジトリ上にブランチが必要です。先ずは先程のupdate-venueブランチをリモートリポジトリにプッシュしましょう。
        
        ```bash
        $ git push origin update-venue # update-venueブランチをリモートリポジトリにプッシュする
        
        % git push origin update-venue
        Enter passphrase for key '/Users/yoshiwo/.ssh/id_ed25519': # パスフレーズを要求されるので入力
        Enumerating objects: 5, done.
        Counting objects: 100% (5/5), done.
        Delta compression using up to 8 threads
        Compressing objects: 100% (3/3), done.
        Writing objects: 100% (3/3), 363 bytes | 363.00 KiB/s, done.
        Total 3 (delta 2), reused 0 (delta 0), pack-reused 0
        remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
        remote: 
        remote: Create a pull request for 'update-venue' on GitHub by visiting:
        remote:      https://github.com/YSWEngineer/ichiyasaGitSample/pull/new/update-venue
        remote: 
        To github.com:YSWEngineer/ichiyasaGitSample.git
         * [new branch]      update-venue -> update-venue
        # これでリモートリポジトリにプッシュされる
        ```
        
    2. masterブランチへのプルリクエスト作成を開始する
        1. プッシュの後、GitHubのichiyasaGitSampleリポジトリをブラウザーで開きます。すると新たに黄色い英亜が表示され、更新されたブランチがあることを確認できます(見当たらない場合、P.157のワンポイントに記載の手順を試してください)。ここからプルリクエスト作成画面に遷移します。
    3. レビュー対象のブランチを選択する
        1. はじめに、レビューの対象としたいトピックブランチとマージ先のブランチ(GitHub上での表示に倣い、プルリクエストでのマージ先をこれ以降ベースブランチと呼びます)を正しく設定しましょう。タイトル入力欄のすぐ上にある選択欄で、左側にベースブランチ、右側にトピックブランチを指定します。

        - **Point** リポジトリとブランチの選択が必要
            
            フォークを行なった場合、リポジトリの指定も必要なので注意してください。デフォルトではフォーク元のyasagit-2/ichiyasaGitSampleがベースブランチに指定されているので、自分のアカウントのリモートリポジトリを選択しなおします。
            
    4. ベースブランチとトピックブランチを選択する
        1. 左側のベースブランチで自分のアカウントのリポジトリを選択します。自分のアカウントのリポジトリのページに遷移するので、ベースブランチとトピックブランチにそれぞれmasterブランチ、update-venueブランチを選択してください。

    5. プルリクエストに必要な情報を入力する
        1. 作成画面には、プルリクエストのタイトルと自由に書けるコメントの入力欄があります。どんな変更を加えたのか、わかりやすく書きましょう。今回は、サンプルとして以下のように記載しています。

        
        ※GitHubでコメントを入力する部分ではMarkdownが使えます。
        
    6. Reviewersにレビュアーを指定する
        1. レビュアーをしてします。例えばシガさんにレビューをお願いしたい場合、画面右側の「Reviewers」にシガさんのユーザー名(shiga-iyg-2)を選択すれば完了です。尚、レビュアーとなるにはそのリポジトリに権限が必要です(P.156参照)。
    7. プルリクエストの内容を確定する
        1. 最後に[Create pull request]をクリックすれば、プルリクエストの作成が完了します。
                
    - **ワンポイント** レビュアーにリポジトリの編集権限を与える
        
        レビュアーに指定できるのは、リポジトリの「コラボレーター(共同編集者)」となっているアカウントです。[Settings]タブで設定します。コラボレーターは、そのリポジトリにプッシュする権限を持ちます。
                
    - **ワンポイント** プルリクエストは専用画面から作成することもできる
        
        先程のプルリクエストは、ブランチをプッシュしたら画面に表示される[Compare & pull request]から作成しました(P.152参照)。実はこのボタンはプッシュから一定時間が経つと表示されなくなります。それ以降にプルリクエストを作りたい際は、[Pull requests]タブの[New pull request]ボタンをクリックしましょう。
### 用語
- **pull request(プルリクエスト)**：マージの依頼のこと。GitHubが提供している機能の一つ。作成したブランチの取り込みを依頼する際に用いる。
- **レビュー**：プルリクエストを使った議論のこと。変更を加えた人以外が内容をチェックするという意味。
- **マージ**：枝分かれさせたブランチを統合すること。
- **レビュアー**：レビューする側のこと。
- **レビュイー**：レビューされる側のこと。
- **プッシュ**：ローカルリポジトリからリモートリポジトリに反映すること。
- **ブランチ**：Gitで記録する履歴を枝分かれさせるための機能。複数の作業を並行して進めるときに使用する。
- **フォーク**：リポジトリを複製するGitHubの機能。複製元となるオリジナルのリポジトリに影響を与えることなく、ファイルに変更を加えることができる。
- **ベースブランチ**：プルリクエストでのマージ先のブランチ。</details>


<details><summary>Lesson 31 [ブランチを用いた実践3] プルリクエストをレビューしてもらいましょう</summary>

このLessonでは、作成したプルリクエストの中身をチームメンバーにレビューしてもらい、マージするための準備を終えるところまでの手順を紹介します。先程までとは視点を変え、レビュー担当者になったつもりで読んでくださいね。

- レビューで確認する内容
    
作成したプルリクエストをマージするために、レビューの工程に移ります。ところで、レビューでは、どんなチェックを行えば良いのでしょうか。これは、プロジェクトごと、レビュアーごとに異なるので、明確な答えがありません。例を挙げると、ソースコードのレビューでは、①ロジックに誤りがないか、②設計が適切か、③他の人によって読みやすいか、④必要なテストコードが書かれているか、⑤ソースコードコメントが十分か？などのポイントがあります。また、今回のサンプルプロジェクトのようにユーザーインターフェースがある場合はデザインや操作性もチェック対象でしょうし、議事録ならば言葉遣いを確認するかもしれません。是非、GitHubでオープンに繰り広げられている議論や、所属しているプロジェクトのレビューなどから学び、感覚を養っていってください。
    
    ※修正点の指摘やネガディブなフィードバックだけがレビューではありません。「綺麗なソースコードですね」「表現がわかりやすいです」といったポジティブなコメントも、積極的に書き込んでみましょう。
    
- プルリクエストのレビューをしよう
    1. プルリクエストの内容をブラウザー上でレビューする
        1. レビュアーに指定されたシガさんは、プルリクエストの内容を確認し、マージ可能かどうかを判断します。今回は、会場の変更内容が正しいかどうか確認できればいいでしょう。プルリクエストの画面で[Files changed]タブをクリックすると、変更前・変更後の内容が比較できます。変更が多い場合や、変更内容を時系列に沿ってみたい場合などは、[Commits]タブをクリックしてコミットごとの確認を行うのもおすすめです。
                
    2. レビューの結果をプルリクエスト作成者に伝える
        1. レビューが完了したら、シガさんはその旨をプルリクエストにコメントします。ここではサンプルとして、次のように入力しました。プルリクエストのマージはLesson 33で実行します。
        
        - **Point** マージの実行者はチームによって異なる
            
            レビュー完了後、マージを誰が行うかはチームによって異なります。今回はレビュアーが実行するフローを紹介していますが、筆者の経験では、レビューを依頼した人がマージするという取り決めをしているチームもありました。どちらを瀬卓するか決める際は、マージの影響をしっかり把握した人が、適切なタイミングで操作を行えるルールになっていることが大切です。
            
- **ワンポイント** 略語を活用し、プルリクエストでの議論をスムーズに
    
    GitHubでのコミュニケーションには、略語を活用する独特の文化があります。最も有名なのが、「問題ないと思う」「良いと思う」という意味の「LGTM(Looks Good To Me)」です。様々な場面で使えますが、プルリクエストの内容を承諾する意味でレビュアーがLGTMを伝えるのは定番です。LGTMと書かれた面白い画像を貼ることもよくあります。LGTM以外にもさまざまな言葉が使われているので、興味がある方は是非調べてみてください。
    
- **ワンポイント** プルリクエストのタイトルやコメントを編集する
    
    プルリクエストに入力した内容は後から編集もできます。タイトルは、右側にある[Edit]ボタンをクリックすると、編集できる状態に気変わります。また、コメントを編集するには、右上にある[…]ボタンをクリックし、[Edit]というメニューを選択します。
### 用語
- **pull request(プルリクエスト)**：マージの依頼のこと。GitHubが提供している機能の一つ。作成したブランチの取り込みを依頼する際に用いる。
- **レビューでのチェック内容**：プロジェクトごと、レビュアーごとに異なるので明確な答えがないが、例を挙げると
    - ①ロジックに誤りがないか、②設計が適切か、③他の人によって読みやすいか、④必要なテストコードが書かれているか、⑤ソースコードコメントが十分か？などのポイントがある。
- **レビュー**：プルリクエストを使った議論のこと。変更を加えた人以外が内容をチェックするという意味。
- **レビュアー**：レビューする側のこと。
- **レビュイー**：レビューされる側のこと。
- **LGTM(Looks Good To Me)**：「問題ないと思う」「良いと思う」という意味の略語。
    - GitHubでのコミュニケーションには略語を活用する独特の文化がある。
    - LGTM画像はレビューOKの合図。</details>


<details><summary>Lesson 32 [ブランチを用いた実践4] GitHubのレビュー機能を使いこなしましょう</summary>

前のLessonでは、プルリクエストに対してコメントを1つつけてレビューを完了しましたが、実はGitHubにはもっと細かく指摘できる便利なレビュー機能が備わっています。その使い方とレビューの流れを紹介します。

- レビュー機能を用いたレビューの流れを知ろう
    
シナリオでは使いませんでしたが、レビューに特化した機能も提供されています。この機能では行単位でコメントを付与していき、修正点や疑問が解消してレビュアーがプルリクエストを「Approve」(承認)したらマージします。細かい単位で確認や議論がしやすい上に、複数のコメントをまとめて1つのレビューとして扱うことが可能です。多くのコミュニケーションを必要とするようなプルリクエストでは活用しがいがあるため、参考までに使い方を紹介しておきます。
    
- レビュアーがプルリクエストを細かくレビューする
    1. 特定の行にコメントをつける
        1. レビュアーは、[Files changed]をクリックし、変更を加えたファイルの行に対してコメントを付与することでレビューを開始します。コメントをしたい行の先頭にマウスポインタを合わせると表示される[+]ボタンをクリックしましょう。

    - **ワンポイント** レビュアーに指定されている場合
        
        今回のシガさんのように、レビュアーに指定された人がプルリクエストを開くと、画面上部にレビューが依頼されていると分かるメッセージが表示されます。併せて表示される[Add your review]ボタンをクリックすると、次の手順3の画面に進み、すぐにレビューを開始できます。
        
    1. コメントを入力する
        1. コメント入力欄が表示されるので、書き込みを行い[Start a review]をクリックしてください。コメントは複数件付けることができますが、2件目以降は同じボタンが[Add review comment]に変わります。
        
        ※レビュー結果としてレビュイーに伝えたい内容を、各行にコメントしていきます。
        
    2. レビュー内容を確定する
        1. コメントにPending(保留)というラベルが付いているのに気付いたでしょうか。コメントを付けただけだとレビューは途中であるとみなされ、レビュイーには公開されません。コメントを公開するには、レビュー内容を確定する必要があります。レビュー全体のコメントを入力するために画面右上の[Finish your review]をクリックしてください。
        
        - **Point** レビューの結果に応じて種類を選ぶ
            
            レビュー全体のコメントを入力する欄の下でレビュー結果の種類を選べます。例えば、「疑問点に回答をお願いします」というメッセージを送るときは「Comment」、「とても良い変更ですね！マージをお願いします」のときは「Approve」、「3点指摘をしたので、修正してください」ならば「Request changes」を選びましょう。尚、プルリクエストを作成した人はApproveとRequest changesを選択できません。前者は本人が勝手に承認するとレビューが漏れることになってしまうため、後者は修正を依頼せずとも自ら直すだけなので不要だからです。
                
    3. レビュー全体のコメントを入力する
        1. コメント入力欄には、今まで付けたコメント全体を踏まえてレビュイーに伝えたいメッセージを入力してください。前ページのPointで紹介したような、「疑問点に回答をお願いします」「とても良い変更ですね！マージをお願いします」「3点指摘をしたので、修正してください」といったものです。コメントの種類を選択し、[Submit review]を押せば公開完了です。
        
- レビュアーからのコメントを確認し、Approveを目指す
    
    レビュー内容が確定されたら、レビュイーはレビュアーが付けたコメントを確認し、必要に応じてコメントを返します。修正の依頼があってファイルの編集が必要な場合は、再びローカルリポジトリで作業し、コミットとプッシュを行います。レビュアーがApprove(承認すること)するまで、コメントのやり取りやファイルの変更を続けましょう。
    
    1. 指摘内容を確認する
        1. レビュイーの立場でレビュー内容を確認します。
        
        - **Point** レビュー中に追加で修正を行うには？
            
            レビュアーの指摘を受け何らかの修正をしたい場合は、再びローカルリポジトリの同じトピックブランチで作業をしましょう。そして、Lesson 29~30で説明した通りにコミットとプッシュを行います。プルリクエストで扱っているトピックブランチに追加でプッシュすると、新しいコミットがプルリクエスト上に表示されます。
            
    2. 指摘に対して対応する
        1. 必要に応じてレビューもコメントを入力し、[Comment]をクリックして投稿します。
        
        ※レビューは共同作業における大事なコミュニケーションの場です。わかりやすく書いたり、人を傷つける言葉は避けたり、マナーを守ってお互い気持ち良くやりましょう！
        
    3. プルリクエストを承認する ~レビュアーの作業~
        1. レビュイーの対応を見て、レビュアーがApprove可能だと判断したら、[Appraove changes]をクリックして承認します。プルリクエスト下部の変更依頼が表示されている箇所で[…]をクリックすると選択できます。それ以外の選択肢もありますが、[Re-request review]はまだ修正が必要な時、[Dismiss review]はレビューを取り下げたいときに使います。あとはマージするだけです。
        - **Point** 絵文字で楽しくコミュニケーション
            
            GitHubのコメント入力では、半角スペースの後に「:」(半角コロン)を入力すると絵文字の入力補完ができます。絵文字の活用でレビューをより楽しくしましょう。
            
- **ワンポイント** コメントごとに解決済みステータスとする
    
    レビュー内のコメントが複数あると、確認や修正が終わったものと終わっていないものを見分けられた方が便利ですよね。区別のために、各行につけたレビューコメントの状態を操作してみましょう。コメントの下部にある[Resolve conversation]というボタンをクリックすると、「解決済み」という状態にできます。解決済みにすると、そのコメントは閉じた状態で表示されるので、まだ議論の必要が残っているコメントが確認しやすくなります。
### 用語
- **pull request(プルリクエスト)**：マージの依頼のこと。GitHubが提供している機能の一つ。作成したブランチの取り込みを依頼する際に用いる。
- **レビュー**：プルリクエストを使った議論のこと。変更を加えた人以外が内容をチェックするという意味。
- **レビュアー**：レビューする側のこと。
- **レビュイー**：レビューされる側のこと。
- **マージ**：枝分かれさせたブランチを統合すること。
- **Comment**：(GitHubのレビューの結果に対して)「疑問点に回答をお願いします」と承認せずにコメントを付ける、という意味。
- **Approve**：(GitHubのレビューの結果に対して)「とても良い変更ですね！マージをお願いします」と承認する、という意味。
- **Request changes**：(GitHubのレビューの結果に対して)「3点指摘したので、修正してください」と修正を依頼する、という意味。
- **コミット：**①ユーザーが任意のタイミングで記録を保持する操作を「コミット」するといい、②その記録自体のことも「コミット」と呼ぶ。
- **プッシュ**：ローカルリポジトリからリモートリポジトリに反映すること。
- **トピックブランチ**：短期的に使う作業用のブランチ。
- **pull request(プルリクエスト)**：マージの依頼のこと。GitHubが提供している機能の一つ。作成したブランチの取り込みを依頼する際に用いる。</details>


<details><summary>Lesson 33 [ブランチを用いた実践5] 作成したブランチをmasterブランチにマージしましょう</summary>

レビューが終わったのでマージの作業をしましょう。これでようやくリモートリポジトリにあるmasterブランチの更新が完了します。実はここまで終えると、「GitHubフロー」というメジャーな開発フローを1周実践したことになります。

- GitHub上で行えるマージには3つの方法がある
    
    GitHub上でのマージに複雑な手順はなく、プルリクエストの画面でボタンを押すだけです。しかし、マージの仕方は「Create a merge commit」「Squash and merge」「Rebase and merge」の3種類があり、「どのようにコミット履歴を残したいか」という方針に応じて適切に選択する必要があります。それぞれの仕組みは次ページで解説しますが、慣れるまでは、履歴に一切手を加えずそのまま残す「Create a merge commit」を選んでおくと良いでしょう。
    
    ※マージ方法によって、コミット履歴の残り方が変わります。どれを選ぶかは、チームのルール次第です。
    
- トピックブランチの全コミットをそのまま保持する
    
    「Create a merge commit」を行うと、トピックブランチに加えたコミットが全てベースブランチにマージされます。さらに、マージコミットというマージを記録する新たなコミットも作成されます。捜査の履歴がそっくりそのまま残るので、後からコミット単位の見直しやバージョン切り替えを行えることが特徴です。

- トピックブランチの全コミットを1つにまとめる「スカッシュ」
    
    「Squash and merge」は、トピックブランチで追加したコミットを1つのコミットにまとめた後でマージします。まとめる操作がスカッシュです。マージコミットを作成する方法とは異なり、マージしたあとは、トピックブランチのコミット単位で細かい履歴を確認することができなくなります。しかしその分、ベースブランチの履歴がプルリクエスト単位で整理された形になるため、見通しが良くなります。

- ベースブランチのコミット履歴を一直線にする「リベース」
    
    「Rebase and merge」では、ブランチの枝分かれ元を変更するリベースという操作をしてからマージを行います。ここからは、下の図を確認しながら読み進めてください。トピックブランチで作業している間、ベースブランチに「a」というコミットが追加されたとします。そこでリベースを行うと、「a」がコミットされた状態のベースブランチからトピックブランチを作成したかのように、トピックブランチの履歴が書き替わります。そのあとにマージすることで、まるで初めから枝分かれしていないかの如く、ベースブランチのコミット履歴を一直線にすることができます。
    
    ※この方法の特徴は、仮にトピックブランチの数が増えたとしても、常に一直線で見やすいコミット履歴を保てることです。

- GitHub上でトピックブランチをマージしよう
    1. 3つのマージ方法から選択する
        1. マージの方法を学び終えたので、実行してみましょう。マージ用ボタンの右側にある三角形をクリックすると選択肢が3つ表示されるので、[Create a merge commit]を選択します。正しく選択できたかは、再度三角形をクリックし、チェックマークがついている箇所を見れば確認できます。

    2. マージを実行する
        1. 選択を終えたら、[Merge pull request]をクリックしてください。マージコミットのコメント入力画面に切り替わります。

    3. マージコミットのコメントを入力する
        1. マージコミットのコメントを入力します。筆者の経験上、特別な理由やルールがない限り、デフォルトで入力されている値をそのまま使うことが多いです。これをもって、作成したプルリクエストは役目を終えたことになります。

        - Point プルリクエストの「オープン」と「クローズ」
            
            トピックブランチをマージすると、プルリクエストの画面には「Pull request successfully merged and closed」と表示されているはずです。直訳すると「プルリクエストは無事マージされ、閉じられました」となりますね。「閉じられた」という言葉は耳慣れないかもしれませんが、プルリクエストの状態を指しています。状態には「オープン」「クローズ」の2種類があり、作成直後はオープン、マージすると自動的にクローズとなるのです。また、不要になったプルリクエストをマージせずに閉じることもできますし、マージせずに閉じたプルリクエストは再度オープンにすることも可能です。
            
- ベースブランチのコミット履歴を確認する
    1. [Code]タブに移動する
        1. ベースブランチにどのような変更が入ったのか確認してみましょう。これは、プルリクエストをマージするたびに必ず行うべき手順というわけではありませんが、特定ブランチの履歴の見方と覚えておきましょう。先ずは[Code]タブへ移動し、[(コミット数)Commit(s)]をクリックします。

        ※Codeタブのファイル一覧にあるindex.htmlを見ると、コミットメッセージと更新日付が他のファイルと違いますね。先程の作業内容が反映されているためです。
        
    2. コミットの履歴を表示する
        1. コミット履歴が表示されます。プルダウンメニューでブランチの選択も可能です。ここでは、masterブランチにupdate-venueブランチのコミットとマージコミットが作成されていることを確認してください。

- **ワンポイント** スカッシュやリベースは履歴の書き替えを行う
    
    一度作成したコミットは変更せず、全ての操作履歴を残すのがGitの基本的な考え方です。しかし、このLessonで登場したスカッシュ、リベースは履歴の書き替えを行う操作です。スカッシュは、複数あったコミットを1つにまとめるという変更を行なっているので納得しやすいのではないでしょうか。リベースも、コミットはそのまま残すものの、実は元のコミットからはハッシュ値が変更されます。そのためこれらの操作を行うと、「いつでも過去の状態に戻ることができる」という特徴を満たせなくなる可能性があるので要注意です。意図しない履歴の書き替えで困らないよう、きちんと理解してから実行しましょう。
    
    ※スカッシュやリベースなど、注意が必要な操作もあることを覚えておいてください。
### 用語
- **マージ**：枝分かれさせたブランチを統合すること。
- **pull request(プルリクエスト)**：マージの依頼のこと。GitHubが提供している機能の一つ。作成したブランチの取り込みを依頼する際に用いる。
- **トピックブランチ**：短期的に使う作業用のブランチ。
- **マージコミット**：トピックブランチに加えたコミットが全てベースブランチにマージされる際に作成されるコミットのこと。
- **スカッシュ**：複数のコミットをまとめること。GitHubでマージの際に使うと、ブランチに加えた変更履歴が1つになる。マージしたあとは、トピックブランチのコミット単位で細かい履歴を確認することができなくなります。
- **リベース**：ブランチを統合する方法の一つ。まるで履歴が枝分かれしていなかったかのように一直線に統合する。
- **ベースブランチ**：プルリクエストでのマージ先のブランチ。</details>


<details><summary>Lesson 34 [プルとフェッチ] リモートリポジトリの内容をローカルリポジトリに取得しましょう</summary>

リモートリポジトリで行ったmasterブランチの更新を、ローカルリポジトリにも取得してみましょう。これで、Chapter 1で説明した、ローカル/リモート2つのリポジトリを用いたサイクルを一周したことになります。

- 2つの選択肢「プル」と「フェッチ」
    
「プル」または「フェッチ」という操作を行うと、指定したリモートリポジトリの内容が使用中のローカルリポジトリに取り込まれます。それぞれの違いは、ワークツリーの内容が変更されるかどうかです。プルを行なった場合、取得内容がワークツリーまで反映され、パソコン内のファイルが即座に書き替わります。一方、フェッチはローカルリポジトリへの取得しか行わないので、ワークツリーに反映させるには再度プルを実行するか、マージを行う必要があります。そのため、両者の関係を表すのに「プル＝フェッチ＋マージ」といった説明がしばしば用いられます。
    
    ※ブランチにすぐ取り込みたい場合はプルを、いきなりマージしたくない事情がある時や、内容を確認したいだけの時などはフェッチを使うといいでしょう。
    
- プルとフェッチの違い
  
    ブランチにすぐ取り込みたい場合はプルを、いきなりマージしたくない事情がある時や、内容を確認したいだけの時などはフェッチを使用すると良い。
  
- リモートからローカルに反映するコマンド
    
    プルは、git pullというコマンドを使います。リモートリポジトリ内のブランチの内容が、ローカルリポジトリ内の同じ名前のブランチに反映されます。同時にワークツリーへの反映も行われます。
    
    フェッチは、git fetchコマンドを使います。リモートリポジトリを指定して実行すると、リモートリポジトリの内容がローカルリポジトリに取得されます。ワークツリーへの反映は行われません。
    
    ※プルとフェッチは、使うコマンドも異なります。違いをしっかり理解しておきましょう。
    
    - git pullコマンド
        
        ```bash
        $ git pull origin master
        # git pull = git pullコマンド
        # origin = プル先のリモートリポジトリの名前
        # master = プルするブランチ名
        ```
        
    - git fetchコマンド
        
        ```bash
        $ git fetch origin
        # git fetch = git fetchコマンド
        # origin = フェッチ先のリモートリポジトリの名前
        ```
        
    - 次ページの手順でマージ後のmasterブランチがローカルに反映される

- GitHub上の変更をローカルリポジトリにも取り込もう
    1. masterブランチに切り替える
        1. Lesson 33で、GitHub上(リモートリポジトリ)でmasterブランチへのマージを行ったので、ローカルリポジトリのmasterブランチにも変更を反映しましょう。現在、ローカルリポジトリはupdate-venueブランチを使用しているので、masterブランチに切り替えます。
        
        ```bash
        $ git checkout master # 現在のupdate-venueブランチから、masterブランチに切り替える
        
        % git checkout master
        Switched to branch 'master'
        Your branch is up to date with 'origin/master'.
        ```
        
        ※ブランチを切り替えずにgit pullコマンドを実行すると、今使っているローカルリポジトリのブランチに、リモートリポジトリのmasterブランチがマージされてしまうので注意しましょう。
        
    2. git pullコマンドを実行する
        1. リポジトリとブランチを指定して、git pullコマンドを実行してください。
        
        ```bash
        $ git pull origin master
        
        % git pull origin master
        Enter passphrase for key '/Users/yoshiwo/.ssh/id_ed25519':  # passphraseを入力してreturnキーを押す
        remote: Enumerating objects: 1, done.
        remote: Counting objects: 100% (1/1), done.
        remote: Total 1 (delta 0), reused 1 (delta 0), pack-reused 0
        Unpacking objects: 100% (1/1), 710 bytes | 355.00 KiB/s, done.
        From github.com:YSWEngineer/ichiyasaGitSample
         * branch            master     -> FETCH_HEAD
           4b9aa4a..b5de101  master     -> origin/master
        Updating 4b9aa4a..b5de101
        Fast-forward
         index.html | 2 +-
         1 file changed, 1 insertion(+), 1 deletion(-)
        # リモートリポジトリの内容が取得される
        ```
        
- **ワンポイント** ローカルリポジトリにまだ存在しないブランチを取得する
    
    P.178で説明したとおり、プルにはマージの操作が含まれます。そのため、実行するには、マージ先となるブランチがローカルリポジトリに存在する必要があります。そのため、リモートリポジトリにしかないブランチを取得したい場合はフェッチを利用します。例えば、シガさんがローカルリポジトリにupdate-venueブランチを取得したい場合、以下のようにgit fetchコマンドとgit checkoutコマンドを使うことで実現できます。このチェックアウトでは、ブランチを作成するにも関わらず、-bオプションが不要です。リモートリポジトリ上のブランチと同名のブランチを指定してチェックアウトをすると、ローカルリポジトリにまだそのブランチがなければGitが自動で作成してくれるのです。
    
    - ローカルリポジトリに存在しないブランチを取得するコマンド
        
        ```bash
        $ git fetch origin
        ```
        
        ```bash
        $ git checkout update-venue
        ```
        
    - 実行結果からローカルリポジトリへの取得成功を確認

    ※他の人が作ったトピックブランチを取得すると、GitHub上では不可能な確認もできるのでレビューでも便利です。例えば、今扱っているシナリオの場合なら、ブラウザーでイベントページの表示確認ができます。また、例えばアプリケーションであれば実行してみることもできますね。
    
- **ワンポイント** チェックアウトは編集した内容を勝手に上書きしない
    
    P.145で説明したように、git checkoutコマンドは、特定のバージョンをワークツリーに反映させます。しかし、ファイルがmodifiedとなっている場合、編集した内容が上書きされる恐れがあるときはチェックアウトできません。Gitが意図しない上書きを防いでくれるというわけです。「error. Your local changes to the following files would be overwritten by checkout (チェックアウトすると次のファイルに対する変更が上書きされてしまう)」というメッセージが表示されるので、コミットしたり、編集を取り消したりする必要があります。
### 用語
- **ワークツリー**：変更するファイルを保持する場所。「ワーキングツリー」「作業ディレクトリ」とも呼ぶ。
- **プル**：リモートリポジトリの内容をローカルリポジトリに取得し、ワークツリーに反映すること。
    - **git pull**：リモートリポジトリ内のブランチの内容が、ローカルリポジトリ内の同じ名前のブランチに反映されます。同時にワークツリーへの反映も行われます。
- **フェッチ**：リモートリポジトリの内容をローカルリポジトリに取得すること。
    - **git fetch**：リモートリポジトリを指定して実行すると、リモートリポジトリの内容がローカルリポジトリに取得されます。ワークツリーへの反映は行われません。
- プルとフェッチの関係を表すのに「**プル＝フェッチ＋マージ**」といった説明が用いられる。
- **リモートリポジトリ**：インターネット上に存在するリポジトリのこと。複数人で共有するものとして、サーバー上に配備するのが一般的。
- **ローカルリポジトリ**：手元で使っているパソコン内に作成する自分専用のリポジトリ。基本的に誰かと共同で使うことはない。
- **ブランチ**：Gitで記録する履歴を枝分かれさせるための機能。
- **git checkoutコマンド**：ワークツリーへの変更を取り消す。ブランチを作る。ブランチを切り替える。コミットした状態に切り替える。と、ひとつのコマンドで色々な操作ができる。一方で多いがためにわかりづらい側面もある。
    - **git checkout --**：直前のコミットの状態に戻す。
- **modified**：「最後にコミットした状態」から変更済みのファイルを表す。</details>


<details><summary>Lesson 35 [GitHubフロー] GitHubフローについて理解しましょう</summary>

ここまでのLesoonで学んできたGitHubフローの知識を整理します。Gitで継続的に作業していくには、操作を覚えるだけではなく、こうしたフローの理解も重要です。しっかり抑え、複数人での作業もスムーズにできるよう準備をしておきましょう。

- 今回実践したのはGitHubフロー
    
    Gitでは、masterに直接コミットをするのではなく、別のブランチを用意して作業を進めることが一般的です。その際重要になるのが、「どんなトピックブランチを作るのか」「いつ何をきっかけにマージするのか」などを定めたフローです。
    
    フローとして代表的なものには「GitHubフロー」「Gitフロー」といったものがありますが、このChapterで行った一連の流れは、GitHubフローに基づいています。GitHubフローは、作業ごとにトピックブランチを1つだけ作り、細かい単位でサイクルを回すフローで、各作業をシンプルに管理できることが特徴です。原則として頻繁なデプロイ(アプリケーションやWebサイトを稼働・公開すること)を前提としています。
    
    - GitHubフローのサイクル
        
        masterブランチからトピックブランチを作成→変更したい内容をコミット→プルリクエストを作成し、レビュー、デプロイ→トピックブランチをmasterブランチにマージ→masterブランチからトピックブランチを作成→......
        
        GitHubのフロー [https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/)
        
- なぜ作業内容ごとにブランチを使い分けるのか
    
    作業ごとにブランチを使い分ける理由について考えてみましょう。第一のメリットとしてあげられるのは、「作業の影響範囲を限定できる」ことです。例えば、ニュースを配信するアプリを開発しているとしましょう。「未読のニュースがあるとユーザーに通知する機能」と、「毎朝7時にニュースの更新通知をする機能」の開発が決まりました。Aさんは、「通知に関する作業」という理由で同じブランチを使って2つの機能の作業を始めました。ところが、未読ニュースの通知機能の開発は順調に開発が完了したのに対し、更新通知はなかなか進みません。というのも、チーム内で「7時ではなくて8時がよい」「ユーザーが選択した時刻に通知すべきだ」と意見が割れ、議論に時間を要したからです。結果として、早くできた未読ニュースの通知機能だけ先にリリースしようという取り決めがなされました。しかし、1つのブランチで2つの作業をごちゃ混ぜに管理してしまっていたため、リリースしたい機能の分の変更だけを抽出するのにAさんは苦労することとなってしまいました。仮に2つの開発が順調に進み、同時期に完了していたとしても、リリース後に片方の機能でバグが発覚したらどうでしょう。実はブランチが分かれていれば、バグのある方だけ元に戻すといったことも比較的容易に行えます。
    
    - 1つのブランチで複数の作業を行うと……
        
        1つのブランチで複数の作業を行うと切り分けがしづらい。
        
- **ワンポイント** 作業の単位はなるべく小さくする
    
    開発は、作業中も作業後も何が起こるかわかりません。いざというときに備え、なるべく作業の単位を小さくしておくと素早く柔軟な対応が可能です。適切な単位で作業をくぎれるようなブランチの使い方を心掛けてみましょう。ブランチごとにサイクルを回すGitHubフローでは、まさにこうしたブランチ管理が実現できますね。
    
- **ワンポイント** プルリクエストの検索機能
    
    プルリクエストは、変更の理由や経緯の記録として、後から見返すと役立つこともあります。しかし、これからいくつもプルリクエストを作っていくと、特定のプルリクエストを一覧から自分の目で見つけるのは少々大変ですよね。そこで、[Pull requests]タブにある検索機能を使うと、キーワードや特定の条件で絞り込みができます。
    
    先ず、キーワード検索は、入力欄に文字を入力してreturnキーを押すだけです。一方、「レビュアーが誰か」「オープンかクローズか」といった条件で行う絞り込みには方法が2つあります。1つは、入力欄の左側にある[Filters]から絞り込み条件を選択すること、もう1つは独自の記法を用いて条件を入力することです。貴方については公式ページ([https://help.github.com/articles/searching-issues-and-pull-requests/](https://help.github.com/articles/searching-issues-and-pull-requests/))に詳しい説明がありますが、例えば、「is:open」はオープンなプルリクエストを、「author:ichiyasa-g-2」はイチヤサさんが作成したプルリクエストを条件として指定できる文字列です。キーワード検索と条件での検索は併用することができます。
    
    - [Filters]で絞り込む
        
        ①[Filters]をクリック
  
        ②絞り込みたい条件を選択。例えば、[Your pull requests]を選ぶと、自分が作成したプルリクエストのみを表示します。
        
    - 記法で絞り込む
        
        ①条件を指定してから、returnキーを押す。
  
        ②「is:closed 株式会社インプレス」と入力することで、クローズ済みのプルリクエストからキーワードで絞り込みができます。
### 用語
- GitHubフロー：GitとGitHubを使って作業する方法として、GitHubが推奨している一連の流れ。</details>

# Chapter 6 複数ブランチを同時に使ってファイルを更新しよう

ブランチ利用の応用編です。トピックブランチを2つ作成し、並行作業をしてみましょう。

作業行程は複雑になりますが、「なぜ今このコマンドを実行するのか」と常に考えながら、順を追って理解してください。

<details><summary>Lesson 36 [シナリオの解説] 複数ブランチを使うためのシナリオを理解しましょう</summary>
    
このChapterはすでにみなさんが知っている機能のみを使って進めていくため、すぐ実践に入ります。先ずはこのLessonでこれから実施する作業の内容を説明しますので、Chapter 5で学んだ操作も思い出しながらシナリオを把握してください。
    
- 1つ目のブランチを用いスピーカー情報を更新する
        
  イベントで登壇するうスピーカーが決まったため、イチヤサさんは専用のブランチを作成してイベントページにスピーカーのプロフィール文とプロフィール画像を追加します。尚、サンプルとして登場するスピーカーは「いろふさん」と「うらがみさん」です。

  しかし、いろふさんのプロフィール画像がまだ手に入っていないものとします。そこで、いろふさんの画像追加はTODOコメント(P.191参照)を残すのみで後回しとし、スピーカー情報の更新を中断します。

- 2つ目のブランチでセッション情報を更新する
        
  スピーカー情報の更新は途中のままにし、セッション情報を更新します。但し、作業の目的や内容が異なるため、使用するのはスピーカー情報用と別のブランチです。セッションの情報の更新は作業を完了させ、masterブランチへのマージまで行います。

- 1つ目のブランチに戻り、スピーカー情報の更新を終える
        
  セッション情報の更新中に、いろふさんのプロフィール画像が手に入ったとします。先ずは2つ目のブランチで加えた変更を1つ目のブランチにも反映させましょう。その後、1つ目のブランチで画像の追加とTODOコメントの削除を行い、コミットとマージを実行します。</details>


<details><summary>Lesson 37 [複数ブランチの使用1] 専用のブランチでスピーカーの情報を更新しましょう</summary>

イベントページに、スピーカーのプロフィール文とプロフィール画像を追加します。すでに作業手順は頭に入っているでしょうか。このLessonではこれまでと少し違う操作を紹介するので、自分に合った方法を見つけてください。
- スピーカー情報を途中まで更新する
    
    Lesson 36で説明したように、今回はspeakers-infoブランチを作成し、スピーカー情報を途中まで追加していきます。使うコマンドもほぼこれまでに説明したものばかりですが、オプションを利用してコマンド数を減らすやり方を説明します。
    
    ※オプションを使って少ないコマンドで目的を達成します。

    - チェックアウトと同時にブランチを作成するコマンド
        
        ```bash
        $ git checkout -b speakers-info
        # git checkout = git checkoutコマンド
        # -b = -bオプション
        # speakers-info = 作成し、切り替えたいブランチ名
        ```
        
    - 変更したファイルをまとめてステージングエリアに追加するコマンド
        
        ```bash
        $ git add -A
        # git add = git addコマンド
        # -A = -Aオプション
        ```
        
- ブランチを作成し、コミットしよう
    1. ブランチを作成し、チェックアウトする
        1. git branchコマンドでブランチを作成し、新しいブランチに切り替えるまでを1コマンドで行ってみましょう。git checkoutコマンドに-bオプションをつけて実行します。ブランチ名はspeakers-infoとします。
        
        ```bash
        $ git checkout -b speakers-info
        
        # git checkoutコマンドでspeakers-infoという名のブランチを作成し、同時にチェックアウトを行う
        % git checkout -b speakers-info
        Switched to a new branch 'speakers-info' # 新しいブランチ「speakers-info」ブランチに切り替わった
        ```
        
        ※打ち間違いなどにより誤ったブランチを作成してしまったら、もう一度masterブランチをチェックアウトした後、改めて正しいコマンドを実行してください。
        
    2. HTMLを更新する
        1. 今回は、HTML(プロフィール文)と画像(プロフィール画像)の更新が必要です。Chapter 3のコラムで紹介したように、Gitではテキストファイルのみでなく、画像のようなバイナリファイルも管理できることを思い出してください。まず、HTMLについては「スピーカー」の欄にプロフィール文を追記します。スピーカー2名分のサンプルを載せるので、みなさんも入力してみてください。
    3. TODOコメントを追加する
        1. 画像は、「images」フォルダーに追加する必要があります。しかし、いろふさんのプロフィール画像がまだ入手できていません。TODOコメントを残し、後から差し替えるものとして仮置きの画像を使っておきます。
        - **Point** あとでやりたい作業を書く「TODOコメント」
            
            プログラミングをしていると、あとでやりたい(やる必要がある)作業に備忘録としてソースコードコメントを付けることがしばしばあります。これを、TODOコメントと呼びます。今回のサンプルでは、いろふさんのプロフィール画像追加があとでやるべき作業として残るため、画像の追加箇所にTODOコメントを書いておきます。HTMLの場合は<!-- -->の間にTODOコメントを書きますが、他の言語を使用する場合はそれぞれの文法でTODOコメントを書いてください。
            
    4. 画像を用意する
        1. 画像を2枚用意します。内容は何でもいいので、みなさんのお好きな画像を使っても構いません。但し、画像ファイル名はHTMLで指定したとおり、それぞれspeaker1.png、speaker2.pngとしてください。サンプルプロジェクトへ画像を追加するには、Visual Studio Code左側のエクスぷローターに表示されている「images」フォルダーに画像をドラッグアンドドロップします。
        
        ※ファイル名さえあっていれば、画像は何でも構いません。
        
    5. ブラウザーでHTMLを確認する
        1. Gitに登録する前に、HTMLが正しく更新されたかをブラウザーで確認しておきましょう。

    6. 編集したファイルをコミットする
        1. ファイルの状態をチェックしたら、コミットしましょう。ここではgit addコマンドに-Aオプションを付け、新規追加・編集・削除したすべてのファイルを一度にステージングエリアへ追加します。そのあとは、これまでどおりコミットをすれば大丈夫です。
        
        ```bash
        $ git status # 現在の状態を確認する
        
        % git status
        On branch speakers-info
        Changes not staged for commit:
          (use "git add <file>..." to update what will be committed)
          (use "git restore <file>..." to discard changes in working directory)
        	modified:   index.html
        
        Untracked files:
          (use "git add <file>..." to include in what will be committed)
        	images/speaker1.png
        	images/speaker2.png
        
        no changes added to commit (use "git add" and/or "git commit -a")
        ```

        ```bash
        $ git add -A # -Aは--allとも書ける
        ```
        
        ※-Aは--allとも書けます。文字数は多いですが、意味がわかりやすいですね。このように、オプションにはわかりやすい書き方と短い省略形が存在することがあります。これは、Git以外のコマンドにも言える特徴です。
        
        ```bash
        $ git status
        
        % git status
        On branch speakers-info
        Changes to be committed:
          (use "git restore --staged <file>..." to unstage)
        	new file:   images/speaker1.png
        	new file:   images/speaker2.png
        	modified:   index.html
        ```

        ```bash
        $ git commit -m "スピーカー情報を追記した"
        
        % git commit -m "スピーカー情報を追記した"
        [speakers-info f5e118d] スピーカー情報を追記した
         3 files changed, 8 insertions(+), 4 deletions(-)
         create mode 100644 images/speaker1.png
         create mode 100644 images/speaker2.png
        ```

    7. リモートリポジトリにプッシュする
        1. スピーカー情報の更新が未完なので、speakers-infoブランチはまだ役目を終えていませんが、プッシュしておきましょう。プルリクエストの作成やリリースなど、リモートリポジトリでの操作を行いたいときに限らず、プッシュはこまめに行うことをオススメします。
        
        ```bash
        $ git push origin speakers-info
        
        % git push origin speakers-info
        Enter passphrase for key '/Users/yoshiwo/.ssh/id_ed25519': 
        Enumerating objects: 9, done.
        Counting objects: 100% (9/9), done.
        Delta compression using up to 8 threads
        Compressing objects: 100% (6/6), done.
        Writing objects: 100% (6/6), 29.90 KiB | 7.47 MiB/s, done.
        Total 6 (delta 2), reused 0 (delta 0), pack-reused 0
        remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
        remote: 
        remote: Create a pull request for 'speakers-info' on GitHub by visiting:
        remote:      https://github.com/YSWEngineer/ichiyasaGitSample/pull/new/speakers-info
        remote: 
        To github.com:YSWEngineer/ichiyasaGitSample.git
         * [new branch]      speakers-info -> speakers-info
        ```

        ※こまめにプッシュしておけば、何らかの不具合でローカルリポジトリのデータが消えて作業内容が失われることを防いだり、他のパソコンでプルして作業したりすることができます。
### 用語
- **git checkoutコマンド**：操作対象となるブランチを指定するコマンド。このコマンドを実行すると、それ以降の操作対象が切り替わり、指定したブランチが使われるようになる。
- **TODOコメント**：あとでやりたい(やる必要がある)作業に備忘録としてソースコードコメントを付けること。
- **ステージングエリア**：コミットするファイルを登録する場所。
- **git status**：現在の状態を確認する。
- **-Aオプション**：-Aは--allとも書ける。
    - オプションにはわかりやすい書き方と短くした省略形が存在する。これはGit以外のコマンドにもいえる特徴。
- **リモートリポジトリ**：インターネット上に存在するリポジトリのこと。複数人で共有するものとして、サーバー上に配備するのが一般的。
- **プッシュ**：ローカルリポジトリからリモートリポジトリに反映すること。
- **ブランチ**：Gitで記録する履歴を枝分かれさせるための機能。複数の作業を並行して進めるときに使用する。
- **pull request(プルリクエスト)**：マージの依頼のこと。GitHubが提供している機能の一つ。作成したブランチの取り込みを依頼する際に用いる。
- **プル**：リモートリポジトリの内容をローカルリポジトリに取得し、ワークツリーに反映すること。
    - **git pull**：リモートリポジトリ内のブランチの内容が、ローカルリポジトリ内の同じ名前のブランチに反映されます。同時にワークツリーへの反映も行われます。</details>


<details><summary>Lesson 38 [複数ブランチの使用2] さらにブランチを作成し、セッションの情報を更新しましょう</summary>

いろふさんのプロフィール画像が手元にないままので、一旦中断してセッション情報の更新に移ります。ここからは、同時に複数のブランチを操作することを学びます。ブランチの使い分けを意識してみましょう。
- 新たなブランチをmasterブランチから作成する
    
    次にセッション情報(タイムテーブル)を更新しましょう。別の作業になるので、最初にセッション情報専用のsessions-infoブランチを作成します。現在使っているのは、先ほど作ったspeakers-infoブランチです。その状態でブランチを作成するコマンドを実行すると、基本的には現在使用中のブランチから新たなブランチが作られます。セッション情報の更新はスピーカー情報の更新とは全く別の作業なので、一度masterブランチに戻って、そこから別のブランチを作成しましょう。
    
    - masterブランチに切り替えずに新たなブランチを作成すると……

        ※ベースブランチをmasterにしないと、speakers-infoブランチで追加したコミットも含まれたブランチが作成されてしまいます。そのため、作業ごとに使い分けができません。
    
- ブランチを作成し、編集後にマージまで進めよう
    1. 新たなブランチをmasterブランチから作成する
        1. 一旦masterブランチに移動してから、sessions-infoという名前のブランチを作成します。
        
        ```bash
        $ git checkout master # masterブランチに移動する
        
        % git checkout master
        Switched to branch 'master'
        Your branch is up to date with 'origin/master'.
        ```
        
        ```bash
        $ git checkout -b sessions-info # sessions-infoブランチを作成して、チェックアウトする
        
        % git checkout -b sessions-info
        Switched to a new branch 'sessions-info'
        ```

    2. ファイルを編集し、マージまで進める
        1. index.htmlファイルを開き、テキストのように、セッション情報を追記します。
    3. ブラウザーでHTMLを確認する

    4. 変更をコミットする
        1. これまでと同じく、index.htmlをステージングエリアに追加し、コミットします。
        
        ```bash
        $ git status
        
        % git status
        On branch sessions-info
        Changes not staged for commit:
          (use "git add <file>..." to update what will be committed)
          (use "git restore <file>..." to discard changes in working directory)
        	modified:   index.html
        
        no changes added to commit (use "git add" and/or "git commit -a")
        ```
        
        ```bash
        $ git add index.html
        
        % git add index.html
        ```
        
        ```bash
        $ git commit -m "セッション情報を記載した"
        
        % git commit -m "セッション情報を記載した"
        [sessions-info 858f97a] セッション情報を記載した
         1 file changed, 2 insertions(+), 2 deletions(-)
        ```

    5. リモートリポジトリにプッシュして、マージする
        1. あとは、Chapter5と同様にリモートリポジトリにプッシュし、プルリクエスト使ってマージを行ってください。ここではぷるリクエスト作成前に実行するコマンドのみ列挙し、詳細は割愛します。
        
        ```bash
        $ git push origin sessions-info
        
        % git push origin sessions-info # リモートリポジトリにプッシュする
        Enter passphrase for key '/Users/yoshiwo/.ssh/id_ed25519': # パスフレーズを要求されるので入力する
        Enumerating objects: 5, done.
        Counting objects: 100% (5/5), done.
        Delta compression using up to 8 threads
        Compressing objects: 100% (3/3), done.
        Writing objects: 100% (3/3), 428 bytes | 428.00 KiB/s, done.
        Total 3 (delta 2), reused 0 (delta 0), pack-reused 0
        remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
        remote: 
        remote: Create a pull request for 'sessions-info' on GitHub by visiting:
        remote:      https://github.com/YSWEngineer/ichiyasaGitSample/pull/new/sessions-info
        remote: 
        To github.com:YSWEngineer/ichiyasaGitSample.git
         * [new branch]      sessions-info -> sessions-info
        ```

- **プルリクエストを作成→マージするまでの流れ：1~5はプルリクエスト作成の手順、6•7はマージを実行する手順、8•9はマージコミットの確認**
    1. プルリクエストを作成する
        1. ブランチをプッシュ(ローカルリポジトリからリモートリポジトリに反映すること)する。
        
        ```bash
        $ git push origin ブランチ名
        ```
        
    2. masterブランチへのプルリクエスト作成を開始する
        1. プッシュ後、GitHubのリポジトリを開くと新たに黄色いエリアが表示され、更新されたブランチがあることを確認できます。エリア右側の[Compare & pull request]をクリックする。
            1. 黄色いエリアがない場合は、**プルリクエストは専用画面から作成することもできる**ので、
                
                ①[Pull requests]タブをクリック
                
                ②[New pull request]をクリック
                
                ③base:とcompare:のブランチを選択
                
                ④[Create pull request]をクリック
                
    3. ベースブランチとトピックブランチを選択する
        1. 左側の[base repository:]を自分のアカウントのリポジトリを選択する。
        2. 自分のアカウントのリポジトリのページに遷移するので、
        3. 自分のアカウントのリポジトリのbase:masterとcompare:を選択する。
    4. プルリクエストに必要な情報を入力する
        1. コメント欄にどのような変更を加えたのか、わかりやすく書くこと。
    5. プルリクエストの内容を確定する
        1. [Create pull request]をクリックして、プルリクエストの作成が完了する。
    6. (プルリクエストを作成したので、マージを行う)3つのマージ方法から選択する
        1. [Merge pull request]の▼をクリック。
        2. [Create a merge commit]を選択。
    7. マージを実行する
        1. 3つのマージ方法を選択したら、[Merge pull request]をクリックする。
    8. マージコミットのコメントを入力する
        1. マージコミットのコメントを確認 ※デフォルト値のままで良い。
        2. [Confirm merge]をクリック。
        3. プルリクエストがマージされると、「Pull request successfully merged and closed」と表示される。
    9. ベースブランチのコミット履歴を確認する
        1. [Code]タブに移動する。
        2. [(コミット数) commits]をクリック。
        3. コミット履歴が表示されるので、マージコミットを確認する。
### 用語
- **git checkoutコマンド**：ワークツリーへの変更を取り消す。ブランチを作る。ブランチを切り替える。コミットした状態に切り替える。と、ひとつのコマンドで色々な操作ができる。一方で多いがためにわかりづらい側面もある。
    - **git checkout --**：直前のコミットの状態に戻す。
- **ステージングエリア**：コミットするファイルを登録する場所。
- **リモートリポジトリ**：インターネット上に存在するリポジトリのこと。複数人で共有するものとして、サーバー上に配備するのが一般的。
- **プッシュ**：ローカルリポジトリからリモートリポジトリに反映すること。
- **pull request(プルリクエスト)**：マージの依頼のこと。GitHubが提供している機能の一つ。作成したブランチの取り込みを依頼する際に用いる。
- **マージ**：枝分かれさせたブランチを統合すること。</details>


<details><summary>Lesson 39 [複数ブランチの使用3] スピーカー情報更新用ブランチに戻り、作業を再開しましょう</summary>

遅れて入手したいろふさんのプロフィール画像を追加するために、再びspeakers-infoブランチで作業を行います。基本的な操作は中断前と同じですが、作業開始時とはmasterブランチの内容が異なっていることがポイントです。
1. Lesson 38ではリモートリポジトリ上でブランチをマージしたため、それはまだローカルリポジトリに反映されていません。git pullコマンドを使って、ローカルリポジトリのmasterブランチを最新状態にします。
- 先にmasterブランチの内容をトピックブランチに取得する
    
    今度はspeakers-infoブランチに切り替えてスピーカー情報の続きをしていきます。但し、masterブランチには、先程sessions-infoブランチで行ったセッション情報に関する作業の内容が含まれています。その作業よりも先に作ったspeakers-infoブランチには、セッション情報が含まれていません。そのため、speakers-infoブランチに最新のmasterブランチの内容を含めるように更新してから、作業を行ってみましょう。
    
    ※ベースブランチに変更が入った場合は、作業中のトピックブランチにも反映させておくことをオススメします。そうしないと両ブランチの差分がどんどん大きくなり、マージ作業のボリュームが大きく複雑になる可能性があります。
- masterブランチから最新の状態を取得する
    1. masterブランチから最新の状態を取得する
        
        ```bash
        $ git checkout master # masterブランチに切り替える
        
        % git checkout master
        Switched to branch 'master'
        Your branch is up to date with 'origin/master'.
        ```
        
        ```bash
        $ git pull origin master
        
        % git pull origin master
        Enter passphrase for key '/Users/yoshiwo/.ssh/id_ed25519':  #パスフレーズを要求されるので入力する
        remote: Enumerating objects: 1, done.
        remote: Counting objects: 100% (1/1), done.
        remote: Total 1 (delta 0), reused 0 (delta 0), pack-reused 0
        Unpacking objects: 100% (1/1), 683 bytes | 341.00 KiB/s, done.
        From github.com:YSWEngineer/ichiyasaGitSample
         * branch            master     -> FETCH_HEAD
           b5de101..0e97f72  master     -> origin/master
        Updating b5de101..0e97f72
        Fast-forward
         index.html | 4 ++--
         1 file changed, 2 insertions(+), 2 deletions(-)
        ```
        
        ※コマンドの実行結果をよく見ると、リモートリポジトリとローカルブランチの差分がファイルごとに表示されています。
        
    2. masterブランチから最新状態を取り込む
        
        続いて、speakers-infoにも反映します。マージ先のブランチ(speakers-info)に移動し、マージ元のブランチ(master)をパラメーターに指定してgit mergeコマンドを実行しましょう。すると、エディターが立ち上がりますが、マージしたことがわかるようなコミットメッセージがあらかじめ入力されています。慣習的にそのままとすることが多いので、編集しないでおきましょう。何もせずにエディターを閉じれば、マージが完了します。
        
        ```bash
        $ git checkout speakers-info # speakers-infoブランチに切り替える
        
        % git checkout speakers-info
        Switched to branch 'speakers-info'
        ```
        
        ```bash
        $ git merge master
        
        % git merge master
        Auto-merging index.html
        ```

        ※index.htmlファイルを開き、speakers-infoブランチを使用している状態でもセッション情報が更新済みであることを確認してみましょう。
        
- HTMLファイルを更新する
    1. スピーカーのプロフィール画像を追加し、コミットする
        1. 「images」フォルダーの画像ファイルspeaker1.pngを、本番用のファイルで上書きしましょう。そして、HTMLファイルのTODOコメントの行を削除しましょう。

    2. 変更をコミットする
        1. 今回は、ステージングエリアへの追加とコミットを一度に行ってみます。-aオプションを付けてgit commitコマンドを実行してください。-aオプションは更新されたファイルをステージングエリアに追加して、そのままコミットします。但し、追加対象となるのはGit管理下に置かれているファイルの変更です。ステージングエリアに加えていない新規ファイルや、一度Gitの管理から除外したファイルは対象外となり、コミットされません。その場合はgit addコマンドを使う必要があります。
        
        ```bash
        $ git status
        
        % git status
        On branch speakers-info
        Changes not staged for commit:
          (use "git add <file>..." to update what will be committed)
          (use "git restore <file>..." to discard changes in working directory)
        	modified:   images/speaker1.png
        	modified:   index.html
        
        no changes added to commit (use "git add" and/or "git commit -a")
        ```
        
        ```bash
        $ git commit -am "いろふさんのプロフィール画像を追加した"
        
        % git commit -am "いろふさんのプロフィール画像を追加した"
        [speakers-info 3d6a0a4] いろふさんのプロフィール画像を追加した
         2 files changed, 1 deletion(-)
         rewrite images/speaker1.png (99%)
        ```
    
        - **Point** 複数のオプションを指定してコマンドを実行する
            
            ここでは、ステージングエリアの追加を行う-a、そしてコミットメント(記録を保持すること)を指定する-mという2つのオプションを指定しています。そのため、次のように分けて入力することもできますが、**複数のオプションは「-am」のように1つのハイフン(-)で連続して指定することもできます。**
            
            ```bash
            $ git commit -a -m "いろふさんのプロフィール画像を追加した"
            ```
            
    3. プルリクエストを作成してマージする
        1. コミットが完了したら、これまでどおりプッシュ、プルリクエスト作成、レビュー、マージを行います。
        
        ```bash
        $ git push origin speakers-info
        
        % git push origin speakers-info
        Enter passphrase for key '/Users/yoshiwo/.ssh/id_ed25519': 
        Enumerating objects: 15, done.
        Counting objects: 100% (15/15), done.
        Delta compression using up to 8 threads
        Compressing objects: 100% (8/8), done.
        Writing objects: 100% (8/8), 25.84 KiB | 6.46 MiB/s, done.
        Total 8 (delta 5), reused 0 (delta 0), pack-reused 0
        remote: Resolving deltas: 100% (5/5), completed with 3 local objects.
        To github.com:YSWEngineer/ichiyasaGitSample.git
           f5e118d..3d6a0a4  speakers-info -> speakers-info
        ```

        ※ブランチを複数使い分けるコツが掴めたでしょうか。自分が今何のためにどのブランチを使っているのか、どのブランチとマージすればいいのか、次はどんなブランチを使えばいいのかといった頭の切り替えが難しいと感じるかもしれませんね。たくさん使って慣れていきましょう。
        
- 不要なブランチをコマンドで削除しよう
    
    これまで様々なトピックブランチを扱ってきましたが、この調子で開発を続けているとリポジトリに余分なブランチが溜まっていってしまいます。例として、sessions-infoブランチを対象に、削除を実行するコマンドを紹介します。
    
    ブランチ名を指定した上で、ローカルリポジトリに対してはgit branchコマンドを、リモートリポジトリに対してはgit pushコマンドを用います。
    
    | 操作対象のリポジトリ | 操作内容 | コマンド |
    | --- | --- | --- |
    | ローカルリポジトリ | マージ済みのブランチを削除する | git branh --delete sessions-info または git branch -d sessions -info |
    | ローカルリポジトリ | マージ状況に関わらずブランチを削除する | git branch -D sessions -info |
    | リモートリポジトリ | ブランチを削除する | git push --delete origin sessions -info または git push origin :sessions -info |
- **ワンポイント** 不要なブランチをGitHub上で削除しよう
    
    GitHub上のリモートリポジトリのブランチをブラウザーから削除する方法も紹介しましょう。プルリクエストでブランチをマージしたときに、[Delete branch]というボタンが表示されることに気付きましたか(P.175参照)。これをクリックすると、プルリクエストで使用したブランチを削除できます。
    
    それ以外のブランチを削除したい場合は、[Code]タブの[〇〇 branches]をクリックしてブランチの一覧を表示して削除します(Openなプルリクエストでマージを検討中のブランチは削除できません)。
### 用語
- **masterブランチ**：Gitのリポジトリを作成する際に自動的に作られるブランチ。リポジトリに最初のコミットを行うと、Gitはmasterという名前のブランチを作成します。
- **ベースブランチ**：プルリクエストでのマージ先のブランチ。
- **リモートリポジトリ**：インターネット上に存在するリポジトリのこと。複数人で共有するものとして、サーバー上に配備するのが一般的。
- **ローカルリポジトリ**：手元で使っているパソコン内に作成する自分専用のリポジトリ。基本的に誰かと共同で使うことはない。
- **git pullコマンド**：リモートリポジトリ内のブランチの内容が、ローカルリポジトリ内の同じ名前のブランチに反映されます。同時にワークツリーへの反映も行われます。
- **マージ**：枝分かれさせたブランチを統合すること。
- **git merge**：ブランチを取り込む。
- **ステージングエリア**：コミットするファイルを登録する場所。
- **-aオプション**：ステージングエリアの追加を行う。
- **-mオプション**：コミットメント(記録を保持すること)を指定する。
- **複数のオプションを指定してコマンドを実行する**：複数のオプションは「-am」のように1つのハイフン(-)で連続して指定することもできます。</details>

# Chapter 7 コンフリクトに対処しよう
並行作業をしていると発生しうる「コンフリクト」という現象の解決方法について学びます。

苦手意識を持たれることも多いテーマですが、ぜひ丁寧に読んで理解を深めてくださいいよいよラストスパート、がんばりましょう。

<details><summary>Lesson 40 [コンフリクトの理解] コンフリクトとは何かを理解しましょう</summary>

コンフリクトについて理解するところから始めましょう。コンフリクトは機能の名前ではなく、Gitを使っていると時々出くわす現象のことです。先ずは、どんなときに、なぜ発生するのか把握しておくことが大事です。
- コンフリクトの発生条件を知ろう
    
    コンフリクトは、マージやリベース、プルなど、ブランチを統合する際に発生しうるものです。わかりやすくするため、このLessonではマージを例にして説明していきます。これまでのChapterで確認してきたように、Gitはgit mergeコマンドさえ実行すれば、適切に内容を統合してくれます。しかし、マージする2つのブランチがそれぞれ同じファイルの同じ箇所に異なる変更を加えていた場合、Gitはマージの仕方を判断することができません。
    
    例えば、masterブランチで、あるファイルに「東京都」と書かれていたとします。そこからトピックブランチを作成し、「北海道」と書き換えてmasterブランチにマージしようとしたところ、masterブランチの内容が別の作業者により「沖縄県」に変更されていたらどうでしょう。Gitは、マージ後に残すべきなのが「北海道」なのか「沖縄県」なのか判断することができないのです。このとき発生するのが「コンクリフト」です。コンフリクトが起きたら、人間がマージ後の正しい姿を判断し、手動でマージを行う必要があります。
    
    ※コンフリクトのことを日本語で「競合」と呼ぶこともあります。

- コンフリクトを解消してブランチをマージする
    
    masterブランチの変更をセッション情報更新用ブランチに取り込もうとすると、コンフリクトが発生します。ヤマグチさんによる変更もイチヤサさんが行っていた変更も失わないようにファイルを書き換え、マージを完了させましょう。ここまでできたら、これまでと同じようにプルリクエストの作成、レビュー、マージを終えて作業完了です。
### 用語
コンフリクト：複数ブランチで(複数人で)同じファイルの同じ箇所を編集した後に起こる衝突。必要な内容を勝手に上書きしないための機能。</details>


<details><summary>Lesson 41 [コンフリクトの発生] コンフリクトを発生させてみましょう</summary>

実際にコンフリクトを発生させましょう。作業自体はこれまで行ってきたものとほぼ同じですが、マージの結果が少し変わるので注目してください。一部、登場人物のヤマグチさんになったつもりで作業していただくため、ややこしいですががんばりましょう。
- セッション情報を更新するためのプルリクエストを作成しよう
    1. ブランチの作成からプルリクエスト作成まで進める
        1. 今回は、change-session-titleというブランチを作成して作業します。前のChapterと同様に、git checkoutコマンドを実行しましょう。
        
        ```bash
        $ git checkout -b change-session-title # 「change-session-title」ブランチを作成し、切り替える
        
        % git checkout -b change-session-title
        Switched to a new branch 'change-sesssion-title'
        ```
        
        - Point ブランチ名の付け方はさまざま
            
            これまでのLessonでいくつかのブランチを作成してきましたが、update-venue、speakers-info、change-session-titleなどその都度命名の仕方が異なっていることに気付いたでしょうか。実はブランチ名の付け方もチームによってさまざまなのです。内容を表していれば名前は自由ということもあれば、案件名を必ず付ける、バグトラッキングシステムのチケットIDを使う、などルールを設けている場合もあり、多岐にわたります。
            
    
    ※Gitは様々な使い方ができるので、運用ルールを決めてチームで合意しておくことがとても大事ですね。ブランチ名の付け方もその一例です。
    
    1. セッションタイトルを書き替える
        1. index.htmlを開いてセッションタイトルを書き替えましょう。うらがみさんのセッションタイトルを、「現場で使える！実践Git」から「めざせ脱初心者！現場で使える実践Git」に変更します。
2. 変更をコミットしてプッシュする
    1. コミット、プッシュを行ったのち、プルリクエストを作成したところで手を止めてください。先程説明したシナリオを実現するため、マージは行いません。少し後で、コンフリクトが起きた状態にして、プルリクエストがどうなるのかを確認します(P.219参照)。
    
    ```bash
    $ git commit -am "うらがみさんのセッションタイトルを更新した" # コミットを作成し、同時にステージングエリアの追加と記録を保持した
    
    % git commit -am "うらがみさんのセッションタイトルを更新した"
    [change-sesssion-title 4de2619] うらがみさんのセッションタイトルを更新した
     1 file changed, 1 insertion(+), 1 deletion(-)
    ```
    
    ```bash
    $ git push origin change-session-title # プッシュコマンドを行う
    
    % git push origin change-session-title
    Enter passphrase for key '/Users/yoshiwo/.ssh/id_ed25519': 
    Enumerating objects: 5, done.
    Counting objects: 100% (5/5), done.
    Delta compression using up to 8 threads
    Compressing objects: 100% (3/3), done.
    Writing objects: 100% (3/3), 396 bytes | 396.00 KiB/s, done.
    Total 3 (delta 2), reused 0 (delta 0), pack-reused 0
    remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
    remote: 
    remote: Create a pull request for 'change-session-title' on GitHub by visiting:
    remote:      https://github.com/YSWEngineer/ichiyasaGitSample/pull/new/change-session-title
    remote: 
    To github.com:YSWEngineer/ichiyasaGitSample.git
     * [new branch]      change-session-title -> change-session-title
    ```
    
    **※ブランチ名を間違えて登録したため解決方法を検索→[gitのローカルのブランチ名を変更したいとき]今開いているブランチをリネームする場合は、単純に新しいブランチ名を指定するだけです**。`git branch -m <新しいブランチ名>`
    
    ※[Create pull request]をクリックして、プルリクエストを作成した状態で放置してください。
- ヤマグチさんによる作業をmasterブランチに反映しよう
    
    さて、ここからはヤマグチさんの作業です。トピックブランチを作成してタイムテーブルのレイアウトを変更し、masterブランチにマージしたとの状態を作り出します。ここでは手順をシンプルにするために、ブラウザー上でGitHubのmasterブランチにあるファイルを直接編集してみましょう。これをもって、ヤマグチさんがトピックブランチを作成し、ファイル編集、コミット、プルリクエスト作成、そしてマージまでを済ませたものと思ってください。
1. GitHubでファイルの編集画面を開く
    1. ブラウザーで、GitHub上にあるリモートリポジトリの画面を開き、ファイル一覧からindex.htmlをクリックします。これでGitHubの画面上にindex.htmlの内容が表示されます。
        
2. index.htmlを編集する
    1. ファイルの右上にある鉛筆の[Edit this file]ボタンをクリックすると、ブラウザー上でファイル編集ができます。タイムテーブルに以下のような変更を加えてみましょう(テキスト参考)。
            
3. 変更をコミットする
    1. 編集が完了したら、下のほうにスクロールしていくと「Commit changes」というフォームが現れます。ここでコミットメッセージを入力し、[Commit changes]をクリックして内容を確定させます。これで、編集した内容を反映するmasterブランチへのコミットが作成されます。
            
    ※テキストと実際の画面と内容が異なっている。
- masterブランチの変更を取得する
    
    ヤマグチさん役はここまでです。さて、masterブランチに入った変更をchange-session-titleブランチに取り込みましょう。手順は、Chapter 6で学習したものと同じです。
    
    1. ローカルリポジトリのmasterブランチを最新化する
        1. 先ずはmasterブランチに切り替え、git pullコマンドで最新化を行いましょう。先程ヤマグチさんとしてGitHub上で編集した内容を取得することができます。
        
        ```bash
        $ git checkout master # masterブランチに切り替える
        
        % git checkout master
        Switched to branch 'master'
        Your branch is up to date with 'origin/master'.
        ```
        
        ```bash
        $ git pull origin master # 最新化して編集した内容を取得する
        
        % git pull origin master
        Enter passphrase for key '/Users/yoshiwo/.ssh/id_ed25519': 
        From github.com:YSWEngineer/ichiyasaGitSample
         * branch            master     -> FETCH_HEAD
        Already up to date.
        ```
        
    2. change-session-titleブランチにmasterブランチをマージする
        1. 続いて、再びchange-session-titleブランチへ戻り、masterブランチをマージします。ところが、これまでとは違い、「CONFLICT(content): Merge conflict in index.html」というメッセージが表示されます。これがコンクリフト発生の合図です。
        
        ```bash
        $ git checkout change-session-title # ブランチを「change-session-title」ブランチに切り替える
        
         git checkout change-session-title
        Switched to branch 'change-session-title'
        ```
        
        ```bash
        $ git merge master # masterブランチをマージする
        
        ```

### 用語
- **git checkout -b ブランチ名**：対象のブランチを新規作成し、切り替える。
- **git commitコマンド**：コミットを作成する(ファイルはステージングエリアからGitディレクトリに移動する(コミット(記録)される))。
    - **git commit -am**：**-aオプション**はステージングエリアの追加を行う。**-mオプション**はコミットメント(記録を保持すること)を指定する。-amと一度にまとめてオプションを行うことが可能。
- **git pushコマンド**：ローカルリポジトリからリモートリポジトリに反映すること。
- **git pullコマンド**：リモートリポジトリ内のブランチの内容が、ローカルリポジトリ内の同じ名前のブランチに反映されます。同時にワークツリーへの反映も行われます。</details>


<details><summary>Lesson 42 [コンフリクトの解消] コンフリクトが発生した際の対応を学びましょう</summary>

コンフリクトの状況を確認する方法と、どう対処したら良いかを説明します。これまでは自動で行えていたマージがうまくいかず少々不安にもなりますが、何が起こっているか把握できれば大丈夫です。慌てず、ファイルを正しい状態へと編集しましょう。
- コンフリクトの発生を確認しよう
    1. git statusコマンドで確認する
        1. git statusコマンドを実行すると、その結果でコンフリクトの発生を確認することができます。「both modified」すなわち、マージ先とマージ元の両ブランチで変更を加えたと書かれているファイルがコンフリクトしています。
        
        ```bash
        $ git status
        ```

    - **ワンポイント** コンフリクト発生時のyouとthem
        
        コンフリクト発生時にファイルの状態を表すメッセージとして、both modified以外に「deleted by them」や「added by you」などと表示されることがあります。いきなり人を表す代名詞が出てきて戸惑うかもしれませんが、youはマージ元である現在使用中のブランチ、themはマージ先のブランチを指します。例えば、使用中のブランチで編集したファイルがマージ先のブランチで削除されていた場合、表示されるのはdeleted by themです。
        
    1. GitHub上で確認する
        1. GitHub上のプルリクエストの画面でもコンフリクトを確認することができます。change-session-titleブランチのプルリクエストを見ると、「This branch has conflicts that must be resolved」(このブランチには解消が必要なコンフリクトがある)と表示され、マージができなくなっているはずです。初めに解説した通り、コンフリクトがあるとGitは正しいマージの内容を判断できず、自動で完了させることができないためです。
                
- ファイルを正しい状態に編集し直そう
    1. コンフリクトの原因となっている箇所を特定する
        1. Visual Studio Codeでindex.htmlを開きましょう。タイムテーブルを見ると、連続する<<<と>>>、そして===で囲まれた部分が見つかると思います。それぞれ、<<<の行から>>>の行までがコンフリクトしている箇所、===の行がマージ先とマージ元の変更箇所の境目です。今回は、以下のようになっているはずです。
                
    2. ファイルを正しく修正しよう
        1. ヤマグチさんが変更したタイムテーブルの形式に合わせながらも、うらがみさんのセッションタイトルを更新した状態を目指してファイル修正をしましょう。コンフリクトの印である記号は、解消と同時に忘れずに削除してください。
        
        ![ファイルを正しく修正しよう.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/23eb809b-1800-4159-8574-3539ea67165f/%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E6%AD%A3%E3%81%97%E3%81%8F%E4%BF%AE%E6%AD%A3%E3%81%97%E3%82%88%E3%81%86.jpeg)
        
- 修正したファイルを再度コミットしよう
    1. ステージングエリアに追加する
        1. 編集が完了したらステージングエリアに追加しましょう。その後git statusコマンドを実行すると、これまでと同様にファイルの編集が確認できます。また、「All conflicts fixed but you are still merging.(use "git commit" to conclude merge)」(コンフリクトは解消したが、マージは終わっていない。コミットを行ってマージを完了させよ)と表示されていますね。コンフリクトにより失敗したマージは、解消してコミットを行うまで、マージしている最中(マージが未完)のままとみなされます。
        
        ```bash
        $ git add -A
        ```
        
        ```bash
        $ git status
        ```

        ※コンフリクト発生中はなるべく他の作業をせず、先ず解消してマージしきることをオススメします。他の作業をすると、コンフリクト解消以外の内容がコミットに入ってしまい、後から作業の意味が分かりづらくなる恐れがあります。
        
    2. マージを完了する
        1. Gitが案内しているとおり、コミットを行うことでマージを完了させます。コマンドのパラメーターは必要ありません。Chapter 6で紹介したように(P.202参照)、コミットメッセージが入力された状態でエディターが立ち上がりますが、何も編集せずに閉じてしまえば大丈夫です。
        
        ```bash
        $ git commit
        ```

    3. リモートリポジトリにプッシュする
        1. コンフリクトの解消が終わったら、これまでどおりプッシュを行いましょう。
        
        ```bash
        $ git push origin change-session-title
        ```

    4. プルリクエストを確認する
        1. プッシュした後でGitHubを表示して再度プルリクエストを確認すると、コンフリクト発生中とは異なり、自動でのマージができるようになっています。あとは、レビューをしてもらい、masterブランチへマージすれば作業完了です。

- **ワンポイント** コンフリクトを解消するために
    
    ファイルの種類や状況によって、コンフリクトが解消できたといえる状態は異なります。今回のように内容が正しいことを確認すればよいケースのみならず、コンパイルやアプリケーションの実行が正しく行えることや、テストに通ることを確認する必要がある場合も多々あります。しかし、ゴールはただ1つ、「ファイルが正しい状態となる」よう編集を行うことです。作業内容の意味を把握し、丁寧に対処するようにしましょう。1人で判断できない時は、コンフリクトの原因となった変更を加えたメンバーに意図を確認したり、チームで相談したり、コミュニケーションを取りながら作業をすることも大事なので覚えておきましょう！</details>

# Chapter 8 GitHubをさらに使いこなそう

GitHubにはたくさんのオープンソースソフトウェアが公開されています。いつか貢献する日を目指して、世界中で公開されているリポジトリに目を向けてみましょう。

<details><summary>Lesson 43 [リポジトリのフォロー] オープンソースソフトウェアのリポジトリへアクセスしよう</summary>

GitHubは世界中の開発者が利用しており、多くのリポジトリを見たり開発に参加したりできます。ここからは世界中の開発者が公開しているリポジトリへアクセスして、オープンソースの世界の広がりを体感してみましょう。
- GitHubでは多くのリポジトリが公開されている
    
    GitHubは2021年12月時点で7300万人以上のユーザーがおり、世界中の開発者に利用されています( https://github.com/about )。開発者はGitHubを通じてさまざまなオープンソースソフトウェア(OSS)の開発に参加したり、設計やソースコートを確認したりできます。
    
    本書で学んでいる「Git」もOSSのうちの1つです。GitHubのGitのリポジトリへアクセスしてみてください。ここではGitのソースコードやこれまでのコミット、リリースバージョンなど、さまざまな情報を確認できます。「contributors」(貢献者)はmasterブランチにコミットが取り込まれた人数を示しており、1000人以上の開発者がGitの開発に貢献しているということがわかります。

- リポジトリをフォローしよう
    
    リポジトリの右上に[Watch][Star]のボタンがあります。[Watch]をクリックすると、そのリポジトリでプルリクエストがマージされた時など、リポジトリの更新情報がアクティビティー(活動)として通知されるようになります。
    
    アクティビティーはGitHubのトップページ([ https://github.com ]( https://github.com ))かNotificationsのページ([ https://github.com/notifications ]( https://github.com/notifications ))で確認できます。[Star]のボタンを押すとユーザーページの[Star]タブにリポジトリをリスト化できます。
    
    リポジトリについている「Star」の数はリポジトリの注目度の高さを示しており、例えばGitHubのトレンドリポジトリのランキング([ https://github.com/trending ]( https://github.com/trending ))は「Star」の数をもとに集計されています。
### 用語
- **OSS**：オープンソースソフトウェアのこと。OSS（オープンソースソフトウェア（Open Source Software））とは、ソースコードが公開されており、無償で誰でも自由に改変、再配布が可能なソフトウェアのことです。OSSは特定の企業でなく、有志によって組織されたコミュニティなどで開発されていることが多く、開発にはプログラマが参加しています。OSSは基本的に自由に使えるためソースコードを見て仕組みを学習することができ、一部を修正して改良したソフトウェアを開発することが出来ます。
- (GitHub上の)**contributors**：貢献者。masterブランチにコミットが取り込まれた人数を示している。
- (GitHub上の)**Releases**：これまでのリリースバージョンを確認できる。
- (GitHub上の)**Watch**：そのリポジトリでプルリクエストがマージされて時など、リポジトリの更新情報がアクティビティー(活動)として通知されるようになる。
- (GitHub上の)**Star**：Starの数はリポジトリの注目度の高さを示しており、GitHubのトレンドリポジトリのランキングはStarの数をもとに集計されている。</details>


<details><summary>Lesson 44 [リポジトリの検索] オープンソースソフトウェアを探してみましょう</summary>

OSSの探し方を紹介します。自分が普段使っているツールやプログラミング言語に関係があるリポジトリを探してみましょう。興味があるリポジトリを見つけたら、後からアクセスしやすいよう「Star」を付けていくことをオススメします。
- 検索ボックスを使ってリポジトリを探そう
    
    目的のOSSがあるなら、サイトの左上の検索ボックスでキーワードを検索できます。
    
    検索ボックスに「git」と入力してみましょう。「git」のキーワードに関連があるリポジトリの一覧が表示されます。
    
    前のLessonで紹介したGitのリポジトリが検索結果の一番上に表示されています。使っているツールやフレームワークのソースコードがGitHubで公開されていないか、調べてみましょう。

- 検索ボックスにキーワードを入力する
  ※「All GitHub」と表示されている結果をクリックすると、GitHub上の全てのリポジトリから検索できます。
- 人気のリポジトリを探そう
    
    検索ボックスでは、キーワードの他にも、「Star」がたくさん付いている注目度の高いリポジトリを探すこともできます。
    
    検索ボックスに「stars:>=10000」と入力してみると、「Star」が10000個以上ついているリポジトリが表示されます。
    
    「stars:>=10000 git」のようなキーワードを付けた検索や、「stars:>=10000 language:java」のように「language:」と付けて特定のプログラミング言語に絞った検索もできます。
    
    興味のあるキーワードやよく利用しているプログラミング言語と合わせて検索をかけてみましょう。他にも、リポジトリが作成された日付やフォークされた数など、多くの検索方法が提供されているので、ぜひ調べてみてください( [ https://help.github.com/articles/searching-for-repositories/ ]( https://help.github.com/articles/searching-for-repositories/ ) )。
- **ワンポイント** トレンドのリポジトリを見てみよう
    
    サイト上部の[Explore]というリンクを押してみましょう。ここでは、みなさんが興味を持ちそうなリポジトリやトレンドのリポジトリが紹介されています。「Trending repositories」は初期設定で1週間のトレンドが表示されていますが、プルダウンメニューで今日や1カ月間のトレンドに切り替えることもできます。
### 用語
プルダウンメニュー：コンピューターのアプリケーションソフトのメニューバーで、特定の位置をマウスでクリックすると、その機能に関連したメニューが垂れ下がるように表示されるコマンドの一覧表。 ドロップダウンメニュー。 プルダウンリスト。</details>


<details><summary>Lesson 45 [Issueやガイドライン] オープンソースソフトウェアに貢献しましょう</summary>

Chapter 5で学んだプルリクエストを作成したり、Issueという機能を利用したりすることで、OSSに貢献できます。このLessonでは、OSSへの貢献する方法の一部を紹介します。本書で学んできたことを活かして、OSSの世界に飛び込んでみましょう！
- Issueを利用してOSSに貢献しよう
    
    OSSのリポジトリを見つけたら、次はそのリポジトリに対して貢献していきましょう。OSSへの貢献というと、ソースコードの追加や修正を想像する方が多いのではないでしょうか。
    
    もちろんソースコードの追加や修正も大切ですが、ハードルが高い場合はドキュメントの追加や修正をしたり、問題を報告したりすることもOSSへの貢献になります。問題を報告するときは、Issue(イシュー)というGitHubの機能を利用しましょう。ソフトウェアのバグや問い合わせなどを1つのIssue上で開発者同士が議論することもできます。
- リポジトリのガイドラインを読もう
    
    リポジトリに貢献するときは、READMEやCONTRIBUTINGというファイルにガイドラインが書かれていることがあるので、このファイルを見つけたときはしっかりと目を通すようにしてください。
    
    尚、CONTRIBUTINGファイルがリポジトリにある場合は、Issueページでイメージのようにアナウンスされます。ガイドラインがなくても、ドキュメントや既に登録されているプルリクエストやIssueが英語で書かれていた場合は、同じように英語で書きましょう。
    
    また、Issueを登録する前には、同じようなIssueが既に登録されていないか確認しましょう。
    
    - CONTRIBUTINGファイルがあるとき
  
      ※ルールをしっかりと守り、みんなが気持ち良くOSSへ貢献できるように気を付けましょう。
- **ワンポイント** GitHubの新しい機能
    
    GitHubにはソースコード管理以外にも、開発効率向上やプロジェクト管理などに役立つ多くの機能があります。
    
    特に、近年多くのチームで取り入れられている「アジャイル開発」や「DevOps」などを実践・促進するのに役立つ機能が多く、日々アップデートされてどんどん便利になっています。
    
    リポジトリの画面にある[Actions]や[Projects]のタブなどで、たくさんある機能の一部を利用できます。チームによってはGitHubをより広く活用しているので、いろんな機能を少しずつ覚えていってGitHubを使いこなしましょう！
- **ワンポイント** READMEファイル
    
    GitHubで公開されている多くのリポジトリには「README」という名前のファイルが配置されており、そのOSSを利用する際のインストールや設定の方法、ライセンスなど、リポジトリに関わる情報が記載されています。あなたがリポジトリを公開すると、世界中の人がそのリポジトリを参照できるようになります。
    
    リポジトリを公開する場合はあらかじめREADMEファイルを作っておき、世界中の開発者があなたが作ったOSSを利用したり、貢献したりする際に必要になりそうな情報を書いておくようにしましょう。GitHubではリポジトリを作成するときに[Add a README file]にチェックマークを付けると、自動で「README.md」ファイルを作成し、コミットされます。
    
    「md」はChapter3で学んだMarkdownファイルの拡張子ですね。
    
    本書では見出しとリストしかMarkdownの記法を使用しませんでしたが、GitHub Guidesにはより多くの記法が記載されているので、ぜひ参考にしてみてください。(  [http://guides.github.com/features/mastering-markdown/](http://guides.github.com/features/mastering-markdown/)  )</details>
